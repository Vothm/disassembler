00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/15/2021 4:57:33 PM

00000000                             1  *-----------------------------------------------------------------
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Vince Maranan
00000000                             4  * Description: CSS422 Final Project
00000000                             5  *-----------------------------------------------------------------
00000000                             6  
00000000                             7  ; Variables
00000000                             8              OPT     CRE 
00000000  =0000A000                  9  stack       EQU     $A000               * Stack Address
00000000  =00000004                 10  shift4bits  EQU     4                   * Shift 4 bits
00000000  =00000008                 11  shift8bits  EQU     8                   * Shift 8 bits 
00000000  =0000000C                 12  shift12bits EQU     12                  * Shift 12 bits
00000000  =00000014                 13  printCount  EQU     20                  * Amount of lines to display to console at once
00000000  =0000000D                 14  CR          EQU     $0D                 
00000000  =0000000A                 15  LF          EQU     $0A                 
00000000                            16  
00000000                            17  
00001000                            18              ORG     $1000
00001000                            19              
00001000  6100 0050                 20  start:      BSR     show        * Intro
00001004  6100 0074                 21              BSR     CLEARALL             
00001008  4FF9 0000A000             22              LEA     stack,SP            * Load stack pointer       
0000100E  45F9 000040CA             23              LEA     message_buffer,A2         * buffer resides in A2
00001014  2C4A                      24              MOVEA.L A2,A6               * reference to start of good buffer
00001016                            25      
00001016  6100 0086                 26  in_start    BSR     INPUT
0000101A  6100 016E                 27              BSR     buffPrep
0000101E  103C 0001                 28              MOVE.B  #1,D0
00001022  43F9 00004088             29              LEA     str_more,A1
00001028  3239 000040B6             30              MOVE.W  strMore_len,D1
0000102E  4E4F                      31              TRAP    #15
00001030  103C 0002                 32              MOVE.B  #2,D0
00001034  4E4F                      33              TRAP    #15
00001036  1611                      34              MOVE.B  (A1),D3     * copy input to D3
00001038  12FC 0057                 35              MOVE.B  #$57,(A1)+  * write in 'W'
0000103C  12BC 006F                 36              MOVE.B  #$6F,(A1)   * write in 'u'
00001040  B63C 0031                 37              CMP.B   #$31,D3     * compare ASCII 1 to D3
00001044  67BA                      38              BEQ     start
00001046  67B8                      39              BEQ     start
00001048  6100 001C                 40              BSR     print_exit
0000104C  4EF9 000040CC             41              JMP     end
00001052                            42          
00001052                            43  ;Utility functions (Printing, clearning, checking addresses)
00001052                            44  
00001052  103C 000D                 45  show        MOVE.B  #13,D0
00001056  43F9 00004000             46              LEA     intro,A1
0000105C  3239 00004034             47              MOVE.W  intro_len,D1
00001062  4E4F                      48              TRAP    #15
00001064  4E75                      49              RTS
00001066                            50  
00001066  103C 0001                 51  print_exit  MOVE.B  #1,D0
0000106A  43F9 000040B8             52              LEA     exit,A1
00001070  3239 000040C8             53              MOVE.W  exit_len,D1
00001076  4E4F                      54              TRAP    #15
00001078  4E75                      55              RTS        
0000107A                            56  
0000107A  4240                      57  CLEARALL    CLR     D0
0000107C  4241                      58              CLR     D1
0000107E  4242                      59              CLR     D2
00001080  4243                      60              CLR     D3
00001082  4244                      61              CLR     D4
00001084  4245                      62              CLR     D5
00001086  4246                      63              CLR     D6
00001088  4247                      64              CLR     D7
0000108A  4E75                      65              RTS
0000108C                            66                          
0000108C  4280                      67  CLEARRIGSTERS     CLR.L   D0                 
0000108E  4281                      68              CLR.L   D1
00001090  4282                      69              CLR.L   D2
00001092  4283                      70              CLR.L   D3
00001094  4284                      71              CLR.L   D4
00001096  4286                      72              CLR.L   D6
00001098  4287                      73              CLR.L   D7
0000109A  4E75                      74              RTS
0000109C                            75  
0000109C                            76                          
0000109C  4E75                      77  EndUtil      RTS
0000109E                            78  
0000109E                            79  INPUT:
0000109E  103C 0001                 80              MOVE.B  #1,D0
000010A2  43F9 00004036             81              LEA     string1,A1
000010A8  3239 0000404E             82              MOVE.W  str_len1,D1         
000010AE  4E4F                      83              TRAP    #15
000010B0  D3FC 0000404E             84              ADDA.L  #str_len1,A1         
000010B6  103C 0002                 85              MOVE.B  #2,D0      
000010BA  4E4F                      86              TRAP    #15
000010BC  4EB9 00001100             87              JSR     asciiTOhex           
000010C2  BA3C 0000                 88              CMP.B   #$00,D5
000010C6  6700 0036                 89              BEQ     endInput            
000010CA  2848                      90              MOVEA.L A0,A4         
000010CC  103C 0001                 91              MOVE.B  #1,D0
000010D0  43F9 00004050             92              LEA     string2,A1
000010D6  3239 00004066             93              MOVE.W  str_len2,D1         
000010DC  4E4F                      94              TRAP    #15         
000010DE  D3FC 00004066             95              ADDA.L  #str_len2,A1
000010E4  103C 0002                 96              MOVE.B  #2,D0
000010E8  4E4F                      97              TRAP    #15
000010EA  4EB9 00001100             98              JSR     asciiTOhex
000010F0  BA3C 0000                 99              CMP.B   #$00,D5
000010F4  6700 0008                100              BEQ          endInput           
000010F8  264C                     101              MOVEA.L A4,A3               
000010FA  2848                     102              MOVEA.L A0,A4               
000010FC  204B                     103              MOVEA.L A3,A0        
000010FE                           104                      
000010FE  4E75                     105  endInput    RTS
00001100                           106  
00001100                           107  ; Take D3 (user input) and put the converted ascii to hex on A4
00001100                           108  asciiTOhex
00001100  48E7 F800                109              MOVEM.L D0-D4,-(SP)         
00001104  1A3C 0001                110              MOVE.B  #1,D5        
00001108  4EB8 108C                111              JSR     CLEARRIGSTERS
0000110C  3C3C 0000                112              MOVE    #0,D6      
00001110                           113        
00001110  1619                     114  loop2       MOVE.B  (A1)+,D3            
00001112  B63C 0030                115              CMP.B   #$30,D3             
00001116  6D00 0068                116              BLT     finish      
0000111A  B63C 003A                117              CMP.B   #$3A,D3             
0000111E  6D00 0042                118              BLT     num_to_hex      
00001122  B63C 0041                119              CMP.B   #$41,D3             
00001126  6D00 0058                120              BLT     finish      
0000112A  B63C 0047                121              CMP.B   #$47,D3             
0000112E  6D00 003C                122              BLT     cap_to_hex
00001132  B63C 0061                123              CMP.B   #$61,D3             
00001136  6D00 0048                124              BLT     finish      
0000113A  B63C 0067                125              CMP.B   #$67,D3             
0000113E  6D00 0036                126              BLT     lower_to_hex
00001142  B63C 0066                127              CMP.B   #$66,D3             
00001146  6E00 0038                128              BGT     finish      
0000114A                           129        
0000114A  5246                     130  resume      ADD     #1,D6               
0000114C  BC7C 0006                131              CMP     #6,D6               
00001150  6700 002E                132              BEQ     finish      
00001154  0C11 0000                133              CMP.B   #$00,(A1)          
00001158  6700 0026                134              BEQ     finish      
0000115C  E984                     135              ASL.L   #4,D4                         
0000115E  4EF8 1110                136              JMP     loop2                              
00001162                           137  
00001162  0403 0030                138  num_to_hex  SUBI.B  #$30,D3             
00001166  D803                     139              ADD.B   D3,D4               
00001168  4EF8 114A                140              JMP     resume              
0000116C                           141  
0000116C  0403 0037                142  cap_to_hex  SUBI.B  #$37,D3             
00001170  D803                     143              ADD.B   D3,D4               
00001172  4EF8 114A                144              JMP     resume              
00001176                           145  
00001176                           146  lower_to_hex
00001176  0403 0057                147              SUBI.B  #$57,D3             
0000117A  D803                     148              ADD.B   D3,D4               
0000117C  4EF8 114A                149              JMP     resume              
00001180                           150  
00001180  2044                     151  finish      MOVE.L  D4,A0
00001182  4246                     152              CLR     D6                  
00001184  4CDF 001F                153              MOVEM.L (SP)+,D0-D4             
00001188  4E75                     154              RTS                         
0000118A                           155          
0000118A                           156  ; Print stuff in the buffer
0000118A  244E                     157  buffPrep    MOVEA.L A6,A2         
0000118C  224A                     158              MOVEA.L A2,A1
0000118E  4EB9 000017F2            159              JSR getLong
00001194  14FC 0009                160              MOVE.B #$09, (A2)+
00001198  4EB9 000011DA            161              JSR     opDecode
0000119E  14BC 0000                162              MOVE.B  #00,(A2)            
000011A2  103C 000D                163              MOVE.B  #13,D0
000011A6  4E4F                     164              TRAP    #15                
000011A8  B9C8                     165              CMPA.L   A0,A4              
000011AA  6F00 002C                166              BLE      endBuff
000011AE  5247                     167              ADDI    #1,D7              
000011B0  BE7C 0014                168              CMP     #printCount,D7
000011B4  66D4                     169              BNE     buffPrep
000011B6  103C 0001                170              MOVE.B  #1,D0
000011BA  43F9 00004068            171              LEA     str_enter,A1
000011C0  3239 00004086            172              MOVE.W  str_en_len,D1
000011C6  4E4F                     173              TRAP    #15
000011C8                           174              
000011C8  103C 0002                175              MOVE.B  #2,D0
000011CC  4E4F                     176              TRAP    #15
000011CE                           177              
000011CE  12BC 0050                178              MOVE.B  #$50,(A1)
000011D2                           179              
000011D2  4247                     180              CLR     D7                  *reset counter
000011D4  4EF8 118A                181              JMP     buffPrep
000011D8                           182              
000011D8  4E75                     183  endBuff     RTS         
000011DA                           184            
000011DA  48E7 FB0E                185  opDecode    MOVEM.L A4-A6/D0-D4/D6-D7,-(SP)      * Save registers
000011DE  4EB8 108C                186              JSR     CLEARRIGSTERS             * Clear registers for use
000011E2  1A3C 0001                187              MOVE.B  #1,D5        * Set good flag until fail
000011E6  3E18                     188              MOVE.W  (A0)+,D7            * Move instruction to D7 & Increment pointer
000011E8  264A                     189              MOVEA.L A2,A3               * Store buffer location                 
Line 190 ERROR: Invalid opcode
000011EA                           190       getOpR     getOpCode               * Decode instruction Test
000011EA                           191  
000011EA                           192  
000011EA                           193  
000011EA                           194  ********************************************************************************************************************** 
000011EA                           195  * Start of opReturn section - clean up process and return to IO
000011EA                           196  ********************************************************************************************************************** 
000011EA  4CDF 70DF                197  opReturn    MOVEM.L (SP)+,D6-D7/D0-D4/A4-A6 
000011EE  4E75                     198              RTS             
000011F0                           199                       
000011F0  3C07                     200  getOpCode   MOVE.W  D7,D6               * Move instruction to shift
000011F2  183C 000C                201              MOVE.B  #shift12bits,D4         * Load shifter register
000011F6  E86E                     202              LSR.W   D4,D6               * Shift right 12 bits
000011F8  CCFC 0006                203              MULU    #6,D6               * Form offset           
000011FC  4BF9 00001208            204              LEA     jmp_table,A5           * Index into the table                                                                                   
00001202  4EB5 6000                205              JSR     00(A5,D6)           * Jump indirect with index (00 indicates word movement)
00001206  4E75                     206              RTS
00001208                           207  
00001208                           208  
00001208                           209  
00001208                           210  ********************************************************************************************************************** 
00001208                           211  * Beginning of ttbl_opable: jmp_table
00001208                           212  * Contains the functions per the first 4 bits of current instruction.
00001208                           213  **********************************************************************************************************tbl_op*** 
00001208                           214  jmp_table      
00001208  4EF9 00001244            215              JMP     hex1_0000            
Line 216 ERROR: Undefined symbol
0000120E  4EF9 004DBD16            216              JMP     he    
00001214                           217              ;JMP     hex1_0010x1_0001        
00001214  4EF9 00001304            218              JMP     hex1_0011
0000121A  4EF9 000013BE            219              JMP     hex1_0100
00001220  4EF9 00001422            220              JMP     hex1_0101
00001226  4EF9 0000142A            221              JMP     hex1_0110
0000122C                           222              ;JMP     hex1_1000P     hex1_0111
0000122C  4EF9 0000143C            223              JMP     hex1_1001
00001232  4EF9 000014FA            224              JMP     hex1_1010
00001238  4EF9 00001502            225              JMP     hex1_1011
0000123E  4EF9 000015B6            226              JMP     hex1_1100
00001244                           227              ;JMP     hex1_1110
00001244                           228              ;JMP     hex1_1111P     hex1_1101
00001244                           229  
00001244                           230  ********************************************************************************************************************** 
00001244                           231  * Case for: first four bits = 0000
00001244                           232  * --(ORI) 
00001244                           233  ********************************************************************************************************************** 
00001244  3C07                     234  hex1_0000   MOVE.W  D7,D6               * Fresh copy of instruction to shift
00001246  0246 0F00                235              ANDI.W  #$0F00,D6           * Isolate second byte
0000124A  183C 0008                236              MOVE.B  #shift8bits,D4          * Load shifter
0000124E  E8AE                     237              LSR.L   D4,D6               * Shift to LSB
00001250  BC3C 0000                238              CMP.B   #$0,D6              * Is this ORI?
00001254  6700 0006                239              BEQ     opORI               * Jump to opORI section
00001258  6600 062C                240              BNE     illegalCode             * No - bad instruction                  
0000125C                           241  
0000125C  14FC 004F                242  opORI       MOVE.B  #'O',(A2)+          * Populate ORI into buffer
00001260  14FC 0052                243              MOVE.B  #'R',(A2)+
00001264  14FC 0049                244              MOVE.B  #'I',(A2)+
00001268  14FC 002E                245              MOVE.B  #'.',(A2)+
0000126C  4EB9 00001786            246              JSR     size2Buffer         * determine & add size to buffer
00001272  14FC 0020                247              MOVE.B  #' ',(A2)+
00001276  14FC 0020                248              MOVE.B  #' ',(A2)+
0000127A  14FC 0020                249              MOVE.B  #' ',(A2)+
0000127E  14FC 0020                250              MOVE.B  #' ',(A2)+            
00001282  14FC 0023                251              MOVE.B  #'#',(A2)+            
00001286  4EB9 000017D8            252              JSR     getAddr             * Add immediate source
0000128C  14FC 002C                253              MOVE.B  #',',(A2)+          * Add comma
00001290  4EB9 0000190A            254              JSR     getEA               * Print off desitination operand
00001296  4EF9 0000129C            255              JMP     end0000             * Skip to end of sub: hex1_0000
0000129C                           256  
0000129C  4E75                     257  end0000     RTS
0000129E                           258  ********************************************************************************************************************** 
0000129E                           259  * Case for: first four bits = 0011                                   
0000129E                           260  * MOVE.B
0000129E                           261  ********************************************************************************************************************** 
0000129E                           262  
0000129E                           263  *hex1_0011  MOVE.B  #'M',(A2)+          * Start of MOVE.B OpCode
0000129E                           264  *            MOVE.B  #'O',(A2)+
0000129E                           265  *            MOVE.B  #'V',(A2)+
0000129E                           266  *            MOVE.B  #'E',(A2)+
0000129E                           267  *            MOVE.B  #'.',(A2)+
0000129E                           268  *            MOVE.B  #'B',(A2)+
0000129E                           269  *            MOVE.B  #' ',(A2)+
0000129E                           270  *            MOVE.B  #' ',(A2)+
0000129E                           271  *            MOVE.B  #' ',(A2)+  
0000129E                           272  *            JSR     getEA               * get source destination
0000129E                           273  *            MOVE.B  #',',(A2)+
0000129E                           274  *            JSR     swap4Move           * swap destination and source regs for getEA
0000129E                           275  *            JSR     getEA     
0000129E                           276  *end0001     RTS 
0000129E                           277  *            
0000129E                           278              
0000129E                           279              
0000129E                           280              
0000129E                           281  ********************************************************************************************************************** 
0000129E                           282  * Case for: first four bits = 0001                                 
0000129E                           283  * MOVE.L, MOVEA.L
0000129E                           284  ********************************************************************************************************************** 
0000129E  14FC 004D                285  hex1_0001   MOVE.B  #'M',(A2)+          * Start of MOVE/A.L OpCodes
000012A2  14FC 004F                286              MOVE.B  #'O',(A2)+
000012A6  14FC 0056                287              MOVE.B  #'V',(A2)+
000012AA  14FC 0045                288              MOVE.B  #'E',(A2)+
000012AE  1C07                     289              MOVE.B  D7,D6               * copy fresh instruction to Shift
000012B0  EC8E                     290              LSR.L   #6,D6               * shift by 6 to isolate bits 6-8 in LSB
000012B2  0246 0007                291              ANDI.W  #$07,D6             * determine if MoveA?
000012B6  BC3C 0001                292              CMP.B   #$1,D6              * is this a MOVEA Function?
000012BA  6600 001C                293              BNE     moveL               * no then move to . portion
000012BE  14FC 0041                294              MOVE.B  #'A',(A2)+
000012C2  14FC 002E                295              MOVE.B  #'.',(A2)+
000012C6  14FC 004C                296              MOVE.B  #'L',(A2)+
000012CA  14FC 0020                297              MOVE.B  #' ',(A2)+
000012CE  14FC 0020                298              MOVE.B  #' ',(A2)+
000012D2  4EF9 000012EC            299              JMP     moveLEA             * skip to filling out source destination
000012D8  14FC 002E                300  moveL       MOVE.B  #'.',(A2)+
000012DC  14FC 004C                301              MOVE.B  #'L',(A2)+
000012E0  14FC 0020                302              MOVE.B  #' ',(A2)+
000012E4  14FC 0020                303              MOVE.B  #' ',(A2)+
000012E8  14FC 0020                304              MOVE.B  #' ',(A2)+  
000012EC  4EB9 0000190A            305  moveLEA     JSR     getEA               * get source destination
000012F2  14FC 002C                306              MOVE.B  #',',(A2)+
000012F6  4EB9 0000136A            307              JSR     swapDestReg  * swap destination and source regs for getEA
000012FC  4EB9 0000190A            308              JSR     getEA     
00001302  4E75                     309  end0010     RTS
00001304                           310   
00001304                           311   
00001304                           312   
00001304                           313  ********************************************************************************************************************** 
00001304                           314  * Case for: first four bits = 0011                                    
00001304                           315  * MOVE.W, MOVEA.W
00001304                           316  ********************************************************************************************************************** 
00001304  14FC 004D                317  hex1_0011   MOVE.B  #'M',(A2)+          * Start of MOVE/A.W OpCodes
00001308  14FC 004F                318              MOVE.B  #'O',(A2)+
0000130C  14FC 0056                319              MOVE.B  #'V',(A2)+
00001310  14FC 0045                320              MOVE.B  #'E',(A2)+
00001314  1C07                     321              MOVE.B  D7,D6               * copy fresh instruction to Shift
00001316  EC8E                     322              LSR.L   #6,D6               * shift by 6 to isolate bits 6-8 in LSB
00001318  0246 0007                323              ANDI.W  #$07,D6             * determin if move A?
0000131C  BC3C 0001                324              CMP.B   #$1,D6              * is this a MOVEA Function?
00001320  6600 001C                325              BNE     moveW               * no then move to . portion
00001324  14FC 0041                326              MOVE.B  #'A',(A2)+          * yes - populate A
00001328  14FC 002E                327              MOVE.B  #'.',(A2)+
0000132C  14FC 0057                328              MOVE.B  #'W',(A2)+
00001330  14FC 0020                329              MOVE.B  #' ',(A2)+
00001334  14FC 0020                330              MOVE.B  #' ',(A2)+
00001338  4EF9 00001352            331              JMP     moveWEA             * skip to filling out source destination
0000133E  14FC 002E                332  moveW       MOVE.B  #'.',(A2)+
00001342  14FC 0057                333              MOVE.B  #'W',(A2)+
00001346  14FC 0020                334              MOVE.B  #' ',(A2)+
0000134A  14FC 0020                335              MOVE.B  #' ',(A2)+
0000134E  14FC 0020                336              MOVE.B  #' ',(A2)+  
00001352  4EB9 0000190A            337  moveWEA     JSR     getEA               * get source destination
00001358  14FC 002C                338              MOVE.B  #',',(A2)+
0000135C  4EB9 0000136A            339              JSR     swapDestReg  * swap destination and source regs for getEA
00001362  4EB9 0000190A            340              JSR     getEA     
00001368  4E75                     341  end0011     RTS 
0000136A                           342  
0000136A                           343  
0000136A                           344  
0000136A  4283                     345  swapDestReg CLR.L   D3                  * Clear (0000) D3 to hold swap value
0000136C  3C07                     346              MOVE.W  D7,D6               * Copy to initial shift get reg bits 9-11
0000136E  E04E                     347              LSR.W   #shift8bits,D6          * shift by 8 (9 total)
00001370  E24E                     348              LSR.W   #1,D6               * shift by 1 (9 total)
00001372  0246 0007                349              ANDI.W  #$0007,D6           * Mask/Isolate last 3 bits
00001376  8646                     350              OR.W    D6,D3               * Place Reg Bits Into D3 for swap
00001378  3C07                     351              MOVE.W  D7,D6               * Copy to get mode bits 6-8
0000137A  E64E                     352              LSR.W   #3,D6               * shift bits 6-8 down 3 to normal ea position 3-5
0000137C  0246 0038                353              ANDI.W  #$0038,D6           * mask bits 3-5
00001380  8646                     354              OR.W    D6,D3               * add the move bits into D3
00001382  4EB9 0000138C            355              JSR     moveSize            * add the move size bits (6-7) into D3 for ea
00001388  3E03                     356              MOVE.W  D3,D7               * swap register mode to determine destination from ea functions
0000138A  4E75                     357              RTS
0000138C                           358              
0000138C                           359              
0000138C  3C07                     360  moveSize    MOVE.W  D7,D6               * get fresh copy to determine MOVE size
0000138E  E04E                     361              LSR.W   #shift8bits,D6          * shift move size bits 12-13 to LSB
00001390  E84E                     362              LSR.W   #shift4bits,D6          
00001392  0246 0003                363              ANDI.W  #$0003,D6           * Isolate move bits
00001396  BC3C 0001                364              CMP.B   #$1,D6              * is this a byte?
0000139A  6700 0020                365              BEQ     mSizeEnd            * yes - byte size already in bits 6-7 of D3
0000139E  BC3C 0002                366              CMP.B   #$2,D6              * is this a L?
000013A2  6700 0014                367              BEQ     moveSizeL           * yes - Or L size to D3 bits 6-7
000013A6  BC3C 0003                368              CMP.B   #$3,D6              * is this a W?
000013AA  6600 04DA                369              BNE     illegalCode             * No- then illegalCode        
000013AE  0043 0040                370  moveSizeW   ORI.W   #$0040,D3           * add size 01 in bits 6-7 (4) into D3
000013B2  4EF9 000013BC            371              JMP     mSizeEnd            * skip to end once done
000013B8  0043 0080                372  moveSizeL   ORI.W   #$0080,D3           * add size 10 in bits 6-7 (4) into D3
000013BC  4E75                     373  mSizeEnd    RTS 
000013BE                           374  
000013BE                           375  
000013BE                           376  
000013BE                           377  ; MOVEM, LEA, NOP
000013BE  3C07                     378  hex1_0100   MOVE.W  D7,D6               * Fresh copy of instruction to shift
000013C0  0246 0100                379              ANDI.W  #$0100,D6           * Test isolate 8th bit for LEA
000013C4  BC7C 0100                380              CMP.W   #$0100,D6           * Test if LEA
000013C8  6700 0022                381              BEQ     opLEA               * Yes finish testing for LEA
000013CC  3C07                     382              MOVE.W  D7,D6               * Copy fresh copy of instruction to shift
000013CE  183C 0008                383              MOVE.B  #shift8bits,D4          * Load 8 bit shifter
000013D2  E86E                     384              LSR.W   D4,D6               * Shift current instruction
000013D4  0246 000F                385              ANDI.W  #$000F,D6           * Isolate last 4 bits (LSB)
000013D8  CCFC 0006                386              MULU    #6,D6               * Form offset for next JMP table
000013DC  4BF9 000016A4            387              LEA     tbl_0100,A5         * Load next JMP table 
000013E2  4EB5 6000                388              JSR     00(A5,D6)           * Jump to next instruction per next 4 bits
000013E6  4EF9 00001420            389              JMP     end0100             * Once returned from jump table, skip to end
000013EC                           390              
000013EC  14FC 004C                391  opLEA       MOVE.B  #'L',(A2)+          * Start input of LEA
000013F0  14FC 0045                392              MOVE.B  #'E',(A2)+
000013F4  14FC 0041                393              MOVE.B  #'A',(A2)+
000013F8  14FC 0020                394              MOVE.B  #' ',(A2)+
000013FC  14FC 0009                395              MOVE.B  #$09,(A2)+ 
00001400  4EB9 0000190A            396              JSR     getEA               * Determine address to go to buffer
00001406  14FC 002C                397              MOVE.B  #',',(A2)+          * Add comma
0000140A  14FC 0041                398              MOVE.B  #'A',(A2)+          * Add A(x)
0000140E  3C07                     399              MOVE.W  D7,D6               * Copy fresh copy of instruction to shift
00001410  183C 0009                400              MOVE.B  #9,D4               * Load 9 bit shifter
00001414  E86E                     401              LSR.W   D4,D6               * Shift current instruction
00001416  0246 000F                402              ANDI.W  #$000F,D6           * Isolate last 4 bits (LSB)
0000141A  0606 0030                403              ADD.B   #$30,D6             * convert data register # to hex digit
0000141E  14C6                     404              MOVE.B  D6,(A2)+            * register # to buffer
00001420  4E75                     405  end0100     RTS
00001422                           406  
00001422  4EB9 00001886            407  hex1_0101   JSR     illegalCode             * Invalid Instruction
00001428  4E75                     408              RTS
0000142A                           409              
0000142A                           410              ***** MOVEM Command
0000142A  4EB9 00001886            411  hex1_0110   JSR     illegalCode
00001430  5448                     412              ADDQ.W  #2,A0
00001432  4E75                     413              RTS
00001434                           414  
00001434  4EB9 00001886            415  hex1_0111   JSR     illegalCode             * Invalid Instruction
0000143A  4E75                     416              RTS
0000143C                           417             
0000143C                           418  
0000143C                           419  
0000143C                           420  ; 1001 SUB
0000143C  14FC 0053                421  hex1_1001   MOVE.B  #'S',(A2)+          * Put ADD into Buff
00001440  14FC 0055                422              MOVE.B  #'U',(A2)+
00001444  14FC 0042                423              MOVE.B  #'B',(A2)+
00001448  4EB9 0000177C            424              JSR     getSize             * return size  in 6 & 7 into D6
0000144E  BC3C 0003                425              CMP.B   #%11,D6             * determine if a ADD or ADDA
00001452  6600 004E                426              BNE     opSUB               * not size 11, then skip to ADD
00001456  14FC 0041                427              MOVE.B  #'A',(A2)+          * yep, detected 11 then ADDA
0000145A  14FC 002E                428              MOVE.B  #'.',(A2)+
0000145E  3C07                     429              MOVE.W  D7,D6               * fresh copy of instruction
00001460  E08E                     430              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
00001462  0246 0001                431              ANDI.W  #$0001,D6           * Isolate last bit for size
00001466  BC3C 0001                432              CMP.B   #%1,D6              * compare for a 1 to determine
0000146A  6700 000C                433              BEQ     subaL               * jump to long, else word
0000146E  14FC 0057                434              MOVE.B  #'W',(A2)+          * add word size into buffer
00001472  4EF9 0000147C            435              JMP     opSUBA
00001478  14FC 004C                436  subaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
0000147C  14FC 0020                437  opSUBA      MOVE.B  #' ',(A2)+
00001480  14FC 0020                438              MOVE.B  #' ',(A2)+
00001484  14FC 0020                439              MOVE.B  #' ',(A2)+
00001488                           440              **** NOTE NEED TO TEST FOR EA to ADD $
00001488  4EB9 0000190A            441              JSR     getEA               * get source operand
0000148E  14FC 002C                442              MOVE.B  #',',(A2)+
00001492  14FC 0041                443              MOVE.B  #'A',(A2)+  
00001496  4EB9 000017BC            444              JSR     highRegBits         * Add register number to buffer
0000149C  4EF9 000016A2            445              JMP     end1101
000014A2                           446              
000014A2  14FC 002E                447  opSUB       MOVE.B  #'.',(A2)+          * finish putting Add.x to buffer
000014A6  4EB9 00001786            448              JSR     size2Buffer         * Determine Size and Add to Buffer
000014AC  14FC 0020                449              MOVE.B  #' ',(A2)+
000014B0  14FC 0020                450              MOVE.B  #' ',(A2)+
000014B4  14FC 0020                451              MOVE.B  #' ',(A2)+
000014B8  14FC 0020                452              MOVE.B  #' ',(A2)+
000014BC  4EB9 000017CE            453              JSR     getDirBit           * get Direction Bit 0 = EA 1 =regs
000014C2  BC3C 0000                454              CMP.B   #%0,D6              * is this EA first?
000014C6  6600 001C                455              BNE     opSUB01             * no, jmp to reg mode first
000014CA  4EB9 0000190A            456              JSR     getEA               * print off effective address
000014D0  14FC 002C                457              MOVE.B  #',',(A2)+          * add comma
000014D4  14FC 0044                458              MOVE.B  #'D',(A2)+          * add register BAM!
000014D8  4EB9 000017BC            459              JSR     highRegBits         * Add register number to buffer
000014DE  4EF9 000014F8            460              JMP     end1001             * jump to exit of sub: hex1_1101
000014E4                           461              
000014E4  14FC 0044                462  opSUB01     MOVE.B  #'D',(A2)+          * start register entry
000014E8  4EB9 000017BC            463              JSR     highRegBits         * add register number
000014EE  14FC 002C                464              MOVE.B  #',',(A2)+          * add comma
000014F2  4EB9 0000190A            465              JSR     getEA               * finish with EA          
000014F8                           466              
000014F8  4E75                     467  end1001     RTS            
000014FA                           468  
000014FA  4EB9 00001886            469  hex1_1010   JSR     illegalCode             * Invalid Instruction
00001500  4E75                     470              RTS
00001502                           471  
00001502                           472  
00001502                           473  
00001502                           474  ********************************************************************************************************************** 
00001502                           475  * Case for: first four bits = 1011
00001502                           476  * --(CMP)
00001502                           477  ********************************************************************************************************************** 
00001502  4EB9 0000177C            478  hex1_1011   JSR     getSize             * return size  in 6 & 7 into D6
00001508  BC3C 0003                479              CMP.B   #%11,D6             * determine if a CMPA
0000150C  6600 005A                480              BNE     opCMPEOR
00001510  14FC 0043                481              MOVE.B  #'C',(A2)+          * Put SUBA into Buff
00001514  14FC 004D                482              MOVE.B  #'M',(A2)+
00001518  14FC 0050                483              MOVE.B  #'P',(A2)+
0000151C  14FC 0041                484              MOVE.B  #'A',(A2)+
00001520  14FC 002E                485              MOVE.B  #'.',(A2)+
00001524  3C07                     486              MOVE.W  D7,D6               * fresh copy of instruction
00001526  E08E                     487              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
00001528  0246 0001                488              ANDI.W  #$0001,D6           * Isolate last bit for size
0000152C  BC3C 0001                489              CMP.B   #%1,D6              * compare for a 1 to determine
00001530  6700 000C                490              BEQ     cmpaL               * jump to long, else word
00001534  14FC 0057                491              MOVE.B  #'W',(A2)+          * add word size into buffer
00001538  4EF9 00001542            492              JMP     opCMPA              * Skip to adding padding and destination
0000153E  14FC 004C                493  cmpaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
00001542  14FC 0020                494  opCMPA      MOVE.B  #' ',(A2)+
00001546  14FC 0020                495              MOVE.B  #' ',(A2)+
0000154A  14FC 0020                496              MOVE.B  #' ',(A2)+
0000154E                           497  
0000154E  4EB9 0000190A            498              JSR     getEA               * get source operand
00001554  14FC 002C                499              MOVE.B  #',',(A2)+
00001558  14FC 0041                500              MOVE.B  #'A',(A2)+
0000155C  4EB9 000017BC            501              JSR     highRegBits         * Get address register number
00001562  4EF9 000015B4            502              JMP     end1011             * Skip to end of sub: hex1_1011
00001568                           503              
00001568  3C07                     504  opCMPEOR    MOVE.W  D7,D6               * fresh value
0000156A  4EB9 000017CE            505              JSR     getDirBit           * determine the direction bit 1 = eor 0 = cmp
00001570  BC3C 0000                506              CMP.B   #%0,D6              * yes, go into CMP     
00001574                           507                     
00001574  14FC 0043                508  opCMP       MOVE.B  #'C',(A2)+          * Populate CMP
00001578  14FC 004D                509              MOVE.B  #'M',(A2)+
0000157C  14FC 0050                510              MOVE.B  #'P',(A2)+
00001580  14FC 002E                511              MOVE.B  #'.',(A2)+
00001584  4EB9 00001786            512              JSR     size2Buffer         * Determine & add size to buffer
0000158A  14FC 0020                513              MOVE.B  #' ',(A2)+
0000158E  14FC 0020                514              MOVE.B  #' ',(A2)+
00001592  14FC 0020                515              MOVE.B  #' ',(A2)+
00001596  14FC 0020                516              MOVE.B  #' ',(A2)+
0000159A  4EB9 0000190A            517              JSR     getEA               * Source Operand
000015A0  14FC 002C                518              MOVE.B  #',',(A2)+
000015A4  14FC 0044                519              MOVE.B  #'D',(A2)+  
000015A8  4EB9 000017BC            520              JSR     highRegBits         * Add register number to buffer
000015AE  4EF9 000015B4            521              JMP     end1011             * Skip to end of sub: hex1_1011
000015B4                           522        
000015B4                           523  
000015B4  4E75                     524  end1011     RTS
000015B6                           525  
000015B6                           526  
000015B6                           527  
000015B6                           528  
000015B6                           529  ********************************************************************************************************************** 
000015B6                           530  * Case for: first four bits = 1100
000015B6                           531  * MULU
000015B6                           532  ********************************************************************************************************************** 
000015B6  3C07                     533  hex1_1100   MOVE.W  D7,D6               * copy instruction for testing
000015B8  EC8E                     534  opMULU      LSR.L   #6,D6               * shift 6 to prep for mulu testing
000015BA  0246 0003                535              ANDI.W  #$3,D6              * mask last 3 bits
000015BE  BC3C 0003                536              CMP.B   #$3,D6              * is this MULU or MULS?
000015C2  6700 0002                537              BEQ     muluMode            * head to mulu  mode to determine immediate  
000015C6  3C07                     538  muluMode    MOVE.W  D7,D6               * fresh copy
000015C8  E68E                     539              LSR.L   #3,D6               * shift bits 3-5 into LSB
000015CA  0246 0007                540              ANDI.W  #$7,D6              * mask for mode bits
000015CE  BC3C 0007                541              CMP.B   #$7,D6              *
000015D2  6700 0008                542              BEQ     movePTR             * increment pointer by word
000015D6  4EF9 00001886            543              JMP     illegalCode     
000015DC                           544  
000015DC  5448                     545  movePTR     ADDQ.W  #2,A0               * increment pointer
000015DE  4EF9 00001886            546              JMP     illegalCode
000015E4                           547          
000015E4                           548  
000015E4  4E75                     549  end1100     RTS
000015E6                           550  
000015E6                           551  ********************************************************************************************************************** 
000015E6                           552  * Case for: first four bits = 1101
000015E6                           553  * --(ADD,ADDA)
000015E6                           554  ********************************************************************************************************************** 
000015E6  14FC 0041                555  hex1_1101   MOVE.B  #'A',(A2)+          * Put ADD into Buff
000015EA  14FC 0044                556              MOVE.B  #'D',(A2)+
000015EE  14FC 0044                557              MOVE.B  #'D',(A2)+
000015F2  4EB9 0000177C            558              JSR     getSize             * return size  in 6 & 7 into D6
000015F8  BC3C 0003                559              CMP.B   #%11,D6             * determine if a ADD or ADDA
000015FC  6600 004E                560              BNE     opADD               * not size 11, then skip to ADD
00001600  14FC 0041                561              MOVE.B  #'A',(A2)+          * yep, detected 11 then ADDA
00001604  14FC 002E                562              MOVE.B  #'.',(A2)+
00001608  3C07                     563              MOVE.W  D7,D6               * fresh copy of instruction
0000160A  E08E                     564              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
0000160C  0246 0001                565              ANDI.W  #$0001,D6           * Isolate last bit for size
00001610  BC3C 0001                566              CMP.B   #%1,D6              * compare for a 1 to determine
00001614  6700 000C                567              BEQ     addaL               * jump to long, else word
00001618  14FC 0057                568              MOVE.B  #'W',(A2)+          * add word size into buffer
0000161C  4EF9 00001626            569              JMP     opADDA
00001622  14FC 004C                570  addaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
00001626  14FC 0020                571  opADDA      MOVE.B  #' ',(A2)+
0000162A  14FC 0020                572              MOVE.B  #' ',(A2)+
0000162E  14FC 0020                573              MOVE.B  #' ',(A2)+
00001632                           574              **** NOTE NEED TO TEST FOR EA to ADD $
00001632  4EB9 0000190A            575              JSR     getEA               * get source operand
00001638  14FC 002C                576              MOVE.B  #',',(A2)+
0000163C  14FC 0041                577              MOVE.B  #'A',(A2)+  
00001640  4EB9 000017BC            578              JSR     highRegBits         * Add register number to buffer
00001646  4EF9 000016A2            579              JMP     end1101
0000164C                           580              
0000164C  14FC 002E                581  opADD       MOVE.B  #'.',(A2)+          * finish putting Add.x to buffer
00001650  4EB9 00001786            582              JSR     size2Buffer         * Determine Size and Add to Buffer
00001656  14FC 0020                583              MOVE.B  #' ',(A2)+
0000165A  14FC 0020                584              MOVE.B  #' ',(A2)+
0000165E  14FC 0020                585              MOVE.B  #' ',(A2)+
00001662  14FC 0020                586              MOVE.B  #' ',(A2)+
00001666  4EB9 000017CE            587              JSR     getDirBit           * get Direction Bit 0 = EA 1 =regs
0000166C  BC3C 0000                588              CMP.B   #%0,D6              * is this EA first?
00001670  6600 001C                589              BNE     opADD01             * no, jmp to reg mode first
00001674  4EB9 0000190A            590              JSR     getEA               * print off effective address
0000167A  14FC 002C                591              MOVE.B  #',',(A2)+          * add comma
0000167E  14FC 0044                592              MOVE.B  #'D',(A2)+          * add register BAM!
00001682  4EB9 000017BC            593              JSR     highRegBits         * Add register number to buffer
00001688  4EF9 000016A2            594              JMP     end1101             * jump to exit of sub: hex1_1101
0000168E                           595              
0000168E  14FC 0044                596  opADD01     MOVE.B  #'D',(A2)+          * start register entry
00001692  4EB9 000017BC            597              JSR     highRegBits         * add register number
00001698  14FC 002C                598              MOVE.B  #',',(A2)+          * add comma
0000169C  4EB9 0000190A            599              JSR     getEA               * finish with EA 
000016A2                           600  
000016A2  4E75                     601  end1101     RTS
000016A4                           602  
000016A4                           603  
000016A4                           604  
000016A4                           605  ********************************************************************************************************************** 
000016A4                           606  * Beginning of 4xxx Op Codes table: tbl_0100 
000016A4                           607  * Contains the functions per the second  4 bits of current instruction.
000016A4                           608  ********************************************************************************************************************** 
000016A4                           609  tbl_0100    *Jump table for all op codes that start with 4XXX
000016A4  4EF9 000016EC            610              JMP     hex4_0000            
000016AA  4EF9 000016F4            611              JMP     hex4_0001            
000016B0                           612              ;JMP     hex4_0010
000016B0                           613              ;JMP     hex4_0011
000016B0                           614              ;JMP     hex4_0100
000016B0  4EF9 00001704            615              JMP     hex4_0101
000016B6                           616              ;JMP     hex4_0110
000016B6  4EF9 0000170C            617              JMP     hex4_0111
000016BC  4EF9 00001714            618              JMP     hex4_1000
000016C2  4EF9 0000172E            619              JMP     hex4_1001
000016C8  4EF9 00001736            620              JMP     hex4_1010
000016CE  4EF9 0000173E            621              JMP     hex4_1011
000016D4  4EF9 00001746            622              JMP     hex4_1100
000016DA  4EF9 0000174E            623              JMP     hex4_1101
000016E0  4EF9 0000175E            624              JMP     hex4_1110
000016E6  4EF9 00001756            625              JMP     hex4_1111
000016EC                           626              
000016EC  4EB9 00001886            627  hex4_0000   JSR     illegalCode
000016F2  4E75                     628              RTS
000016F4                           629              
000016F4  4EB9 00001886            630  hex4_0001   JSR     illegalCode
000016FA  4E75                     631              RTS
000016FC                           632              
000016FC  4EB9 00001886            633  hex4_0011   JSR     illegalCode
00001702  4E75                     634              RTS
00001704                           635                            
00001704                           636              
00001704  4EB9 00001886            637  hex4_0101   JSR     illegalCode
0000170A  4E75                     638              RTS
0000170C                           639          
0000170C                           640              
0000170C  4EB9 00001886            641  hex4_0111   JSR     illegalCode
00001712  4E75                     642              RTS
00001714                           643              
00001714                           644              
00001714                           645  ********************************************************************************************************************** 
00001714                           646  * Case for: 0100 1000 (MOVEM)                                                          
00001714                           647  ********************************************************************************************************************** 
00001714  3C07                     648  hex4_1000   MOVE.W  D7,D6           * copy instruction
00001716  E88E                     649              LSR.L   #shift4bits,D6      * shift by 4 bits
00001718  0246 000F                650              ANDI.W  #$000F,D6       * isolate last byte
0000171C  BC3C 0004                651              CMP.B   #$4,D6          * Determine if SWAP
00001720  6600 0004                652              BNE     opMOVEM         * No - go to MOVEM
00001724                           653  
00001724  4E75                     654              RTS            
00001726                           655  
00001726  4EB9 00001886            656  opMOVEM     JSR     illegalCode
0000172C  4E75                     657              RTS   
0000172E                           658  
0000172E  4EB9 00001886            659  hex4_1001   JSR     illegalCode
00001734  4E75                     660              RTS   
00001736  4EB9 00001886            661  hex4_1010   JSR     illegalCode
0000173C  4E75                     662              RTS   
0000173E  4EB9 00001886            663  hex4_1011   JSR     illegalCode
00001744  4E75                     664              RTS
00001746  4EB9 00001886            665  hex4_1100   JSR     illegalCode
0000174C  4E75                     666              RTS
0000174E  4EB9 00001886            667  hex4_1101   JSR     illegalCode
00001754  4E75                     668              RTS
00001756  4EB9 00001886            669  hex4_1111   JSR     illegalCode
0000175C  4E75                     670              RTS   
0000175E                           671  
0000175E                           672  
0000175E                           673  ********************************************************************************************************************** 
0000175E                           674  * Case for: 0100 1110 (NOP)                                                      
0000175E                           675  ********************************************************************************************************************** 
0000175E  4EB9 0000177C            676  hex4_1110   JSR     getSize             
00001764  BC3C 0002                677              CMP.B   #%10,D6             
00001768  6600 011C                678              BNE     illegalCode             
0000176C                           679               
0000176C  14FC 004E                680              MOVE.B  #'N',(A2)+          ; print nop
00001770  14FC 004F                681              MOVE.B  #'O',(A2)+
00001774  14FC 0050                682              MOVE.B  #'P',(A2)+
00001778  4E75                     683              RTS
0000177A                           684  
0000177A                           685              
0000177A  4E75                     686  hex2_1111   RTS    
0000177C                           687  
0000177C                           688  
0000177C                           689  ********************************************************************************************************************** 
0000177C                           690  * Beginning of functions: illegalCode, getSize, size2Buffer, 
0000177C                           691  ********************************************************************************************************************** 
0000177C  3C07                     692  getSize     MOVE.W  D7,D6               * copy current instruction to shift
0000177E  EC4E                     693              LSR.W   #6,D6               * move the size bits in 6-7 to LSB
00001780  0246 0003                694              ANDI.W  #$0003,D6           * remove other non-size bits and store result into D6
00001784  4E75                     695              RTS
00001786                           696  
00001786  4EB8 177C                697  size2Buffer JSR     getSize             * run sizing Commands
0000178A  BC3C 0000                698              CMP.B   #%00,D6             * is tihs a byte?
0000178E  6700 001C                699              BEQ     mainB               * yes, add B to buffer
00001792  BC3C 0001                700              CMP.B   #%01,D6             * is this a word?
00001796  6700 001E                701              BEQ     mainW               * yes, add teh W to buffer
0000179A  BC3C 0002                702              CMP.B   #%10,D6             * is this a long?
0000179E  6600 00E6                703              BNE     illegalCode             * No? then bad instruction
000017A2                           704        
000017A2  14FC 004C                705              MOVE.B  #'L',(A2)+          * add L to buffer
000017A6  4EF9 000017BA            706              JMP     mainEnd             * end size2Buffer sub  
000017AC                           707              
000017AC  14FC 0042                708  mainB       MOVE.B  #'B',(A2)+          * add B to buffer
000017B0  4EF9 000017BA            709              JMP     mainEnd             * end size2Buffer sub
000017B6                           710              
000017B6  14FC 0057                711  mainW       MOVE.B  #'W',(A2)+          * add W to buffer
000017BA  4E75                     712  mainEnd     RTS                         * end size2Buffer sub                        
000017BC                           713  
000017BC  3C07                     714  highRegBits MOVE.W  D7,D6               * get fresh copy of instruction
000017BE  E08E                     715              LSR.L   #shift8bits,D6          * shift by 8 (9total)
000017C0  E28E                     716              LSR.L   #1,D6               * shift by 1
000017C2  0206 0007                717              ANDI.B  #$7,D6              * isolate last 7 bits for register number
000017C6  0606 0030                718              ADD.B   #$30,D6             * convert register number to ascii
000017CA  14C6                     719              MOVE.B  D6,(A2)+            * put register numbert into buffer
000017CC  4E75                     720              RTS
000017CE                           721  
000017CE  3C07                     722  getDirBit   MOVE.W  D7,D6               * get fresh copy of instruction
000017D0  E08E                     723              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
000017D2  0206 0001                724              ANDI.B  #01,D6              * isolate last bit for testing & return in D6
000017D6  4E75                     725              RTS  
000017D8                           726              
000017D8  BC3C 0000                727  getAddr     CMP.B   #%00,D6             * test if value is a byte - assumes D6 already loaded
000017DC  6700 0244                728              BEQ     putbytebuffer         * yes? - load B worth of address into buffer
000017E0  BC3C 0001                729              CMP.B   #%01,D6             * test if value is a word - assumes D6 already loaded
000017E4  6700 024A                730              BEQ     appendWordBuffer         * yes? - load W worth of address into buffer
000017E8  BC3C 0002                731              CMP.B   #%10,D6             * test if value is a long - assumes D6 already loaded
000017EC  6700 0254                732              BEQ     long2Buffer         * yes? - load L worth of address into buffer
000017F0  4E75                     733              RTS
000017F2                           734  
000017F2  4EB9 00001850            735  getLong     JSR     cmdSh1              * Clear D6 and load value for shift
000017F8  183C 000C                736              MOVE.B  #shift12bits,D4         * Load shifter w/12
000017FC  4EB9 00001858            737              JSR     cmdSh2              * Shift
00001802  183C 0008                738              MOVE.B  #shift8bits,D4          * Load shifter w/8
00001806  4EB9 00001858            739              JSR     cmdSh2              * Shift
0000180C  183C 0004                740              MOVE.B  #shift4bits,D4          * Load shifter w/4
00001810  4EB9 00001858            741              JSR     cmdSh2              * Shift
00001816  183C 0000                742              MOVE.B  #0,D4
0000181A  4EB9 00001872            743              JSR     cmdSh4              * Shift
00001820  183C 000C                744              MOVE.B  #shift12bits,D4         * Load shifter w/12
00001824  4EB9 00001872            745              JSR     cmdSh4              * Shift
0000182A  183C 0008                746              MOVE.B  #shift8bits,D4          * Load shifter w/8
0000182E  4EB9 00001872            747              JSR     cmdSh4              * Shift
00001834  183C 0004                748              MOVE.B  #shift4bits,D4          * Load shifter w/4
00001838  4EB9 00001872            749              JSR     cmdSh4              * Shift
0000183E  183C 0000                750              MOVE.B  #0,D4               * Load shifter
00001842  E8AE                     751              LSR.L   D4,D6               * Shift
00001844  0286 0000000F            752              ANDI.L  #$0000000F,D6       * Isolate last bit
0000184A  4EB9 000018F2            753              JSR     converToHex           * Place value in D6 into buffer
00001850                           754  
00001850  7C00                     755  cmdSh1      MOVEQ   #$0,D6              * Clear D6
00001852  2C08                     756              MOVE.L  A0,D6               * Load current address to print
00001854  4846                     757              SWAP    D6                  * Swap high and low word
00001856  4E75                     758              RTS
00001858                           759  
00001858  E8AE                     760  cmdSh2      LSR.L   D4,D6               * Shift
0000185A  0286 0000000F            761              ANDI.L  #$0000000F,D6       * Isolate last bit
00001860  4EB9 000018F2            762              JSR     converToHex           * Place value in D6 into buffer
00001866  4EB8 1850                763              JSR     cmdSh1              * Reset D6 for next shift
0000186A  4E75                     764              RTS
0000186C                           765  
0000186C  7C00                     766  cmdSh3      MOVEQ   #$0,D6              * Clear D6
0000186E  2C08                     767              MOVE.L  A0,D6               * Load current address to print
00001870  4E75                     768              RTS
00001872                           769              
00001872  E8AE                     770  cmdSh4      LSR.L   D4,D6               * Shift
00001874  0286 0000000F            771              ANDI.L  #$0000000F,D6       * Isolate last bit
0000187A  4EB9 000018F2            772              JSR     converToHex           * Place value in D6 into buffer
00001880  4EB8 186C                773              JSR     cmdSh3              * Reset D6 for next shift
00001884  4E75                     774              RTS
00001886                           775              
00001886  1A3C 0000                776  illegalCode     MOVE.B  #0,D5         
0000188A  244B                     777              MOVEA.L A3,A2               
0000188C  14FC 0044                778              MOVE.B  #'D',(A2)+          
00001890  14FC 0041                779              MOVE.B  #'A',(A2)+
00001894  14FC 0054                780              MOVE.B  #'T',(A2)+
00001898  14FC 0041                781              MOVE.B  #'A',(A2)+
0000189C  14FC 0009                782              MOVE.B  #$09,(A2)+
000018A0  14FC 0024                783              MOVE.B  #'$',(A2)+          
000018A4  4EB9 000018AC            784              JSR     loadDataBuffer          
000018AA  4E75                     785              RTS          
000018AC                           786  
000018AC  7C00                     787  loadDataBuffer      MOVEQ   #$0,D6              
000018AE  3C07                     788                      MOVE.W  D7,D6               
000018B0  183C 000C                789                      MOVE.B  #shift12bits,D4         
000018B4  E8AE                     790                      LSR.L   D4,D6               
000018B6  0246 000F                791                      ANDI.W  #$000F,D6           
000018BA  4EB9 000018F2            792                      JSR     converToHex           
000018C0  3C07                     793                      MOVE.W  D7,D6
000018C2  183C 0008                794                      MOVE.B  #shift8bits,D4
000018C6  E8AE                     795                      LSR.L   D4,D6
000018C8  0246 000F                796                      ANDI.W  #$000F,D6
000018CC  4EB9 000018F2            797                      JSR     converToHex           
000018D2  3C07                     798                      MOVE.W  D7,D6
000018D4  183C 0004                799                      MOVE.B  #shift4bits,D4
000018D8  E8AE                     800                      LSR.L   D4,D6
000018DA  0246 000F                801                      ANDI.W  #$000F,D6
000018DE  4EB9 000018F2            802                      JSR     converToHex           
000018E4  3C07                     803                      MOVE.W  D7,D6
000018E6  0246 000F                804                      ANDI.W  #$000F,D6
000018EA  4EB9 000018F2            805                      JSR     converToHex           
000018F0  4E75                     806                      RTS
000018F2                           807              
000018F2                           808  ; Convert hex to ascii
000018F2  BC3C 000A                809  converToHex   CMP.B   #$A,D6              * Confirm hex character?
000018F6  6C00 000A                810              BGE     letter              * Is it a letter or number?
000018FA  0606 0030                811              ADDI.B  #$30,D6             * Convert decimal to ASCII
000018FE  6000 0006                812              BRA     hexToBuffer          
00001902                           813              
00001902  0606 0037                814  letter      ADDI.B  #$37,D6
00001906  14C6                     815  hexToBuffer MOVE.B  D6,(A2)+
00001908  4E75                     816              RTS
0000190A                           817              
0000190A                           818  getEA       
0000190A  4BF9 00001934            819              LEA         addresstable,A5 * load EA_mode jump table
00001910  4282                     820              CLR.L   D2
00001912  4283                     821              CLR.L   D3
00001914  4284                     822              CLR.L   D4           
00001916  4286                     823              CLR.L   D6
00001918  3C07                     824              MOVE.W  D7,D6                 * move word into D6 for manipulation
0000191A  0246 003F                825              ANDI.W  #$003F,D6             * leave only the mode bits
0000191E  123C 0003                826              MOVE.B      #3,D1                 * Store number of bits we wish to shift            
00001922  E26E                     827              LSR.W       D1,D6                 * Shift to the Right to isolate mode bits            
00001924                           828  
00001924  CCFC 0006                829              MULU      #6,D6            * Form Offset for passing to Jump Index table            
00001928  4EB5 6000                830              JSR         00(A5,D6)          * Now we have the index, back to Index table        
0000192C                           831  
0000192C  4E75                     832              RTS                                * return from EA routine
0000192E                           833          
0000192E  4EF9 000040CC            834              JMP         END                    * Return
00001934                           835  
00001934                           836  addresstable                             
00001934  4EF9 00001964            837              JMP     EAcode000             ; Data Register Direct (mode 0)
0000193A  4EF9 00001976            838              JMP     EAcode001             ; Address Register Direct (mode 1)
00001940  4EF9 00001988            839              JMP     EAcode010             ; Address Register Indirect (mode 2)
00001946  4EF9 000019A2            840              JMP     EAcode011             ; Address Register Indirect with Post Increment (mode 3)
0000194C  4EF9 000019C0            841              JMP     EAcode100             ; Address Register Indirect with Pre Decrement (mode 4)
00001952  4EF9 000019DE            842              JMP     EAcode101             ; Absolute Word Address (mode 7, subclass 0)
00001958  4EF9 000019E2            843              JMP     EAcode110             ; Absolute Long Address (mode 7, subclass 1)
0000195E  4EF9 000019E6            844              JMP     EAcode111             * Immediate Data (mode 7 subclass 4)
00001964                           845  
00001964                           846  EAcode000
00001964  3C07                     847              MOVE.W      D7,D6                   * move current working word into temp storage
00001966  0246 0007                848              ANDI.W      #$7,D6                  * isolate register bits (last 3)
0000196A  14FC 0044                849              MOVE.B      #'D',(A2)+              * add "D" to buffer
0000196E  0606 0030                850              ADD.B       #$30,D6                 * convert data register # to hex digit
00001972  14C6                     851              MOVE.B      D6,(A2)+                * register # to buffer                  
00001974                           852              
00001974  4E75                     853          RTS                                     * Return
00001976                           854   
00001976                           855  EAcode001
00001976  3C07                     856              MOVE.W      D7,D6                   * move current working word into temp storage
00001978  0246 0007                857              ANDI.W      #$7,D6                  * isolate register bits (last 3)
0000197C  14FC 0041                858              MOVE.B      #'A',(A2)+              * add "A" to buffer
00001980  0606 0030                859              ADD.B       #$30,D6                 * convert data register # to hex digit
00001984  14C6                     860              MOVE.B      D6,(A2)+                * register # to buffer
00001986                           861                
00001986  4E75                     862              RTS                                 * Return
00001988                           863  
00001988                           864  EAcode010
00001988  3C07                     865              MOVE.W      D7,D6                   * move current working word into temp storage
0000198A  0246 0007                866              ANDI.W      #$7,D6                  * isolate register bits (last 3)
0000198E  14FC 0028                867              MOVE.B      #'(',(A2)+              * add "(" to buffer            
00001992  14FC 0041                868              MOVE.B      #'A',(A2)+              * add "A" to buffer
00001996  0606 0030                869              ADD.B       #$30,D6                 * convert data register # to hex digit
0000199A  14C6                     870              MOVE.B      D6,(A2)+                * register # to buffer
0000199C  14FC 0029                871              MOVE.B      #')',(A2)+              * add ")" to buffer
000019A0                           872               
000019A0  4E75                     873              RTS                                 * Return
000019A2                           874   
000019A2                           875  EAcode011
000019A2                           876              
000019A2  3C07                     877              MOVE.W      D7,D6                   * move current working word into temp storage
000019A4  0246 0007                878              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019A8  14FC 0028                879              MOVE.B      #'(',(A2)+              * add "(" to buffer            
000019AC  14FC 0041                880              MOVE.B      #'A',(A2)+              * add "A" to buffer
000019B0  0606 0030                881              ADD.B       #$30,D6                 * convert data register # to hex digit
000019B4  14C6                     882              MOVE.B      D6,(A2)+                * register # to buffer
000019B6  14FC 0029                883              MOVE.B      #')',(A2)+              * add ")" to buffer
000019BA  14FC 002B                884              MOVE.B      #'+',(A2)+              * add "+" to buffer
000019BE  4E75                     885              RTS
000019C0                           886  
000019C0  3C07                     887  EAcode100   MOVE.W      D7,D6                   * move current working word into temp storage
000019C2  0246 0007                888              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019C6  14FC 002D                889              MOVE.B      #'-',(A2)+              * add "-" to buffer
000019CA  14FC 0028                890              MOVE.B      #'(',(A2)+              * add "(" to buffer            
000019CE  14FC 0041                891              MOVE.B      #'A',(A2)+              * add "A" to buffer
000019D2  0606 0030                892              ADD.B       #$30,D6                 * convert data register # to hex digit
000019D6  14C6                     893              MOVE.B      D6,(A2)+                * register # to buffer
000019D8  14FC 0029                894              MOVE.B      #')',(A2)+              * add ")" to buffer
000019DC  4E75                     895              RTS                                     * Return
000019DE                           896              
000019DE                           897  EAcode101
000019DE  4EF8 1886                898              JMP    illegalCode          * set bad instruction flag
000019E2                           899  EAcode110
000019E2  4EF8 1886                900              JMP       illegalCode             * set bad instruction flag
000019E6                           901  
000019E6  3C07                     902  EAcode111   MOVE.W D7, D6
000019E8  0246 0007                903              ANDI.W #$07, D6
000019EC  0C06 0000                904              CMPI.B   #$0,D6              
000019F0  6700 003E                905              BEQ      appendWordBuffer         
000019F4  0C06 0001                906              CMPI.B   #$1,D6              
000019F8  6700 0048                907              BEQ      long2Buffer         
000019FC  0C06 0002                908              CMPI.B   #$2,D6
00001A00  0C06 0002                909              CMPI.B   #$2,D6              
00001A04  6700 0004                910              BEQ      pctobuffer  
00001A08  4E75                     911              RTS
00001A0A                           912  
00001A0A                           913  ;;; Adding things to buffer 
00001A0A                           914  ; Add '(pc)' to buffer
00001A0A                           915  pctobuffer
00001A0A  4EB9 00001A30            916              JSR         appendWordBuffer
00001A10  14FC 0028                917              MOVE.B      #'(',(A2)+                        
00001A14  14FC 0050                918              MOVE.B      #'P',(A2)+              
00001A18  14FC 0043                919              MOVE.B      #'C',(A2)+              
00001A1C  14FC 0029                920              MOVE.B      #')',(A2)+                                     
00001A20  4E75                     921              RTS
00001A22                           922  
00001A22                           923  putbytebuffer   
00001A22  14FC 0024                924              MOVE.B  #'$',(A2)+
00001A26  4284                     925              CLR.L   D4          
00001A28  3410                     926              MOVE.W  (A0),D2     
00001A2A  4284                     927              CLR.L   D4          
00001A2C  183C 0002                928              MOVE.B  #2,D4       
00001A30                           929              
00001A30                           930  appendWordBuffer 
00001A30  14FC 0024                931              MOVE.B  #'$',(A2)+  
00001A34  4284                     932              CLR.L   D4          * pre-emptive clearout
00001A36  14FC 0024                933              MOVE.B  #$24,(A2)+  * put dollar sign in buffer (before address)
00001A3A  3410                     934              MOVE.W  (A0),D2       * move current word into D2 for rolling purposes
00001A3C  4284                     935              CLR.L   D4          * pre-emptive clearout
00001A3E  183C 0004                936              MOVE.B  #4,D4       * load a counter
00001A42                           937              
00001A42                           938  long2Buffer
00001A42  14FC 0024                939              MOVE.B  #'$',(A2)+
00001A46  4284                     940              CLR.L   D4          * pre-emptive clearout
00001A48  2410                     941              MOVE.L  (A0),D2       * move current word into D2 for rolling purposes
00001A4A  4284                     942              CLR.L   D4          * pre-emptive clearout
00001A4C  183C 0008                943              MOVE.B  #8,D4       * load a counter
00001A50                           944  
00001A50                           945                     
00004000                           946               ORG   $4000 ; Make sure data starts at $4000
00004000= 48 65 6C 6C 6F 2C ...    947  intro        DC.B    'Hello, please enter beginning and ending addresses',CR,LF
00004034                           948  
00004034= 0034                     949  intro_len   DC.W    intro_len-intro
00004036                           950          
00004036= 45 6E 74 65 72 20 ...    951  string1     DC.B    'Enter start address: $',0
0000404E= 0018                     952  str_len1    DC.W    str_len1-string1  *Get the length of the string
00004050                           953  
00004050= 45 6E 74 65 72 20 ...    954  string2     DC.B    'Enter end address: $',0
00004066= 0016                     955  str_len2    DC.W    str_len2-string2  *Get the length of the string
00004068                           956  
00004068= 50 72 65 73 73 20 ...    957  str_enter   DC.B    'Press enter to read more data',0
00004086= FFE2                     958  str_en_len  DC.W    str_enter-str_en_len
00004088                           959  
00004088= 44 69 73 61 73 73 ...    960  str_more    DC.B    'Disassemble more code? 1 for yes, 0 for no. ',0
000040B6= 002E                     961  strMore_len DC.W    strMore_len-str_more       
000040B8                           962  
000040B8= 43 6C 6F 73 69 6E ...    963  exit        DC.B    'Closing program',0
000040C8= 0010                     964  exit_len    DC.W    exit_len-exit           
000040CA                           965  
000040CA= 01                       966  message_buffer    DC.B   1
000040CB                           967                                   
000040CB                           968  *************************************************************************************************************************
000040CB                           969  * End of program:
000040CB                           970  *************************************************************************************************************************        
000040CC  4E72 2700                971  END         STOP    #$2700
000040D0                           972              END     $1000

2 errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDAL               1622
ADDRESSTABLE        1934
APPENDWORDBUFFER    1A30
ASCIITOHEX          1100
BUFFPREP            118A
CAP_TO_HEX          116C
CLEARALL            107A
CLEARRIGSTERS       108C
CMDSH1              1850
CMDSH2              1858
CMDSH3              186C
CMDSH4              1872
CMPAL               153E
CONVERTOHEX         18F2
CR                  D
EACODE000           1964
EACODE001           1976
EACODE010           1988
EACODE011           19A2
EACODE100           19C0
EACODE101           19DE
EACODE110           19E2
EACODE111           19E6
END                 40CC
END0000             129C
END0010             1302
END0011             1368
END0100             1420
END1001             14F8
END1011             15B4
END1100             15E4
END1101             16A2
ENDBUFF             11D8
ENDINPUT            10FE
ENDUTIL             109C
EXIT                40B8
EXIT_LEN            40C8
FINISH              1180
GETADDR             17D8
GETDIRBIT           17CE
GETEA               190A
GETLONG             17F2
GETOPCODE           11F0
GETSIZE             177C
HEX1_0000           1244
HEX1_0001           129E
HEX1_0011           1304
HEX1_0100           13BE
HEX1_0101           1422
HEX1_0110           142A
HEX1_0111           1434
HEX1_1001           143C
HEX1_1010           14FA
HEX1_1011           1502
HEX1_1100           15B6
HEX1_1101           15E6
HEX2_1111           177A
HEX4_0000           16EC
HEX4_0001           16F4
HEX4_0011           16FC
HEX4_0101           1704
HEX4_0111           170C
HEX4_1000           1714
HEX4_1001           172E
HEX4_1010           1736
HEX4_1011           173E
HEX4_1100           1746
HEX4_1101           174E
HEX4_1110           175E
HEX4_1111           1756
HEXTOBUFFER         1906
HIGHREGBITS         17BC
ILLEGALCODE         1886
INPUT               109E
INTRO               4000
INTRO_LEN           4034
IN_START            1016
JMP_TABLE           1208
LETTER              1902
LF                  A
LOADDATABUFFER      18AC
LONG2BUFFER         1A42
LOOP2               1110
LOWER_TO_HEX        1176
MAINB               17AC
MAINEND             17BA
MAINW               17B6
MESSAGE_BUFFER      40CA
MOVEL               12D8
MOVELEA             12EC
MOVEPTR             15DC
MOVESIZE            138C
MOVESIZEL           13B8
MOVESIZEW           13AE
MOVEW               133E
MOVEWEA             1352
MSIZEEND            13BC
MULUMODE            15C6
NUM_TO_HEX          1162
OPADD               164C
OPADD01             168E
OPADDA              1626
OPCMP               1574
OPCMPA              1542
OPCMPEOR            1568
OPDECODE            11DA
OPLEA               13EC
OPMOVEM             1726
OPMULU              15B8
OPORI               125C
OPRETURN            11EA
OPSUB               14A2
OPSUB01             14E4
OPSUBA              147C
PCTOBUFFER          1A0A
PRINTCOUNT          14
PRINT_EXIT          1066
PUTBYTEBUFFER       1A22
RESUME              114A
SHIFT12BITS         C
SHIFT4BITS          4
SHIFT8BITS          8
SHOW                1052
SIZE2BUFFER         1786
STACK               A000
START               1000
STRING1             4036
STRING2             4050
STRMORE_LEN         40B6
STR_ENTER           4068
STR_EN_LEN          4086
STR_LEN1            404E
STR_LEN2            4066
STR_MORE            4088
SUBAL               1478
SWAPDESTREG         136A
TBL_0100            16A4
