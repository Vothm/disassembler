00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/15/2021 4:10:22 PM

00000000                             1  *-----------------------------------------------------------------
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Vince Maranan
00000000                             4  * Description: CSS422 Final Project
00000000                             5  *-----------------------------------------------------------------
00000000                             6  
00000000                             7  ; Variables
00000000                             8              OPT     CRE 
00000000  =0000A000                  9  stack       EQU     $A000               * Stack Address
00000000  =00000004                 10  shift4bits  EQU     4                   * Shift 4 bits
00000000  =00000008                 11  shift8bits  EQU     8                   * Shift 8 bits 
00000000  =0000000C                 12  shift12bits EQU     12                  * Shift 12 bits
00000000  =00000014                 13  printCount  EQU     20                  * Amount of lines to display to console at once
00000000  =0000000D                 14  CR          EQU     $0D                 
00000000  =0000000A                 15  LF          EQU     $0A                 
00000000                            16  
00000000                            17  
00001000                            18              ORG     $1000
00001000                            19              
00001000  6100 0050                 20  start:      BSR     show        * Intro
00001004  6100 0074                 21              BSR     CLEARALL             
00001008  4FF9 0000A000             22              LEA     stack,SP            * Load stack pointer       
0000100E  45F9 000040CA             23              LEA     message_buffer,A2         * buffer resides in A2
00001014  2C4A                      24              MOVEA.L A2,A6               * reference to start of good buffer
00001016                            25      
00001016  6100 0076                 26  in_start    BSR     INPUT
0000101A  6100 016E                 27              BSR     buffPrep
0000101E  103C 0001                 28              MOVE.B  #1,D0
00001022  43F9 00004088             29              LEA     str_more,A1
00001028  3239 000040B6             30              MOVE.W  strMore_len,D1
0000102E  4E4F                      31              TRAP    #15
00001030  103C 0002                 32              MOVE.B  #2,D0
00001034  4E4F                      33              TRAP    #15
00001036  1611                      34              MOVE.B  (A1),D3     * copy input to D3
00001038  12FC 0057                 35              MOVE.B  #$57,(A1)+  * write in 'W'
0000103C  12BC 006F                 36              MOVE.B  #$6F,(A1)   * write in 'u'
00001040  B63C 0031                 37              CMP.B   #$31,D3     * compare ASCII 1 to D3
00001044  67BA                      38              BEQ     start
00001046  67B8                      39              BEQ     start
00001048  6100 001C                 40              BSR     print_exit
0000104C  4EF9 000040CC             41              JMP     end
00001052                            42          
00001052                            43  ;Utility functions (Printing, clearning, checking addresses)
00001052                            44  
00001052  103C 000D                 45  show        MOVE.B  #13,D0
00001056  43F9 00004000             46              LEA     intro,A1
0000105C  3239 00004034             47              MOVE.W  intro_len,D1
00001062  4E4F                      48              TRAP    #15
00001064  4E75                      49              RTS
00001066                            50  
00001066  103C 0001                 51  print_exit  MOVE.B  #1,D0
0000106A  43F9 000040B8             52              LEA     exit,A1
00001070  3239 000040C8             53              MOVE.W  exit_len,D1
00001076  4E4F                      54              TRAP    #15
00001078  4E75                      55              RTS        
0000107A                            56  
0000107A  4240                      57  CLEARALL    CLR     D0
0000107C  4241                      58              CLR     D1
0000107E  4242                      59              CLR     D2
00001080  4243                      60              CLR     D3
00001082  4244                      61              CLR     D4
00001084  4245                      62              CLR     D5
00001086  4246                      63              CLR     D6
00001088  4247                      64              CLR     D7
0000108A  4E75                      65              RTS
0000108C                            66                          
0000108C  4E75                      67  EndUtil      RTS
0000108E                            68  
0000108E                            69  INPUT:
0000108E  103C 0001                 70              MOVE.B  #1,D0
00001092  43F9 00004036             71              LEA     string1,A1
00001098  3239 0000404E             72              MOVE.W  str_len1,D1         
0000109E  4E4F                      73              TRAP    #15
000010A0  D3FC 0000404E             74              ADDA.L  #str_len1,A1         
000010A6  103C 0002                 75              MOVE.B  #2,D0      
000010AA  4E4F                      76              TRAP    #15
000010AC  4EB9 000010F0             77              JSR     asciiTOhex           
000010B2  BA3C 0000                 78              CMP.B   #$00,D5
000010B6  6700 0036                 79              BEQ     endInput            
000010BA  2848                      80              MOVEA.L A0,A4         
000010BC  103C 0001                 81              MOVE.B  #1,D0
000010C0  43F9 00004050             82              LEA     string2,A1
000010C6  3239 00004066             83              MOVE.W  str_len2,D1         
000010CC  4E4F                      84              TRAP    #15         
000010CE  D3FC 00004066             85              ADDA.L  #str_len2,A1
000010D4  103C 0002                 86              MOVE.B  #2,D0
000010D8  4E4F                      87              TRAP    #15
000010DA  4EB9 000010F0             88              JSR     asciiTOhex
000010E0  BA3C 0000                 89              CMP.B   #$00,D5
000010E4  6700 0008                 90              BEQ          endInput           
000010E8  264C                      91              MOVEA.L A4,A3               
000010EA  2848                      92              MOVEA.L A0,A4               
000010EC  204B                      93              MOVEA.L A3,A0        
000010EE                            94                      
000010EE  4E75                      95  endInput    RTS
000010F0                            96  
000010F0                            97  ; Take D3 (user input) and put the converted ascii to hex on A4
000010F0                            98  asciiTOhex
000010F0  48E7 F800                 99              MOVEM.L D0-D4,-(SP)         
000010F4  1A3C 0001                100              MOVE.B  #1,D5        
000010F8  4EB9 000018FC            101              JSR     clrRegs
000010FE  3C3C 0000                102              MOVE    #0,D6      
00001102                           103        
00001102  1619                     104  loop2       MOVE.B  (A1)+,D3            
00001104  B63C 0030                105              CMP.B   #$30,D3             
00001108  6D00 0068                106              BLT     finish      
0000110C  B63C 003A                107              CMP.B   #$3A,D3             
00001110  6D00 0042                108              BLT     num_to_hex      
00001114  B63C 0041                109              CMP.B   #$41,D3             
00001118  6D00 0058                110              BLT     finish      
0000111C  B63C 0047                111              CMP.B   #$47,D3             
00001120  6D00 003C                112              BLT     cap_to_hex
00001124  B63C 0061                113              CMP.B   #$61,D3             
00001128  6D00 0048                114              BLT     finish      
0000112C  B63C 0067                115              CMP.B   #$67,D3             
00001130  6D00 0036                116              BLT     lower_to_hex
00001134  B63C 0066                117              CMP.B   #$66,D3             
00001138  6E00 0038                118              BGT     finish      
0000113C                           119        
0000113C  5246                     120  resume      ADD     #1,D6               
0000113E  BC7C 0006                121              CMP     #6,D6               
00001142  6700 002E                122              BEQ     finish      
00001146  0C11 0000                123              CMP.B   #$00,(A1)          
0000114A  6700 0026                124              BEQ     finish      
0000114E  E984                     125              ASL.L   #4,D4                         
00001150  4EF8 1102                126              JMP     loop2               
00001154                           127  
00001154  0403 0030                128  num_to_hex  SUBI.B  #$30,D3             
00001158  D803                     129              ADD.B   D3,D4               
0000115A  4EF8 113C                130              JMP     resume              
0000115E                           131  
0000115E  0403 0037                132  cap_to_hex  SUBI.B  #$37,D3             
00001162  D803                     133              ADD.B   D3,D4               
00001164  4EF8 113C                134              JMP     resume              
00001168                           135  
00001168                           136  lower_to_hex
00001168  0403 0057                137              SUBI.B  #$57,D3             
0000116C  D803                     138              ADD.B   D3,D4               
0000116E  4EF8 113C                139              JMP     resume              
00001172                           140  
00001172  2044                     141  finish      MOVE.L  D4,A0
00001174  4246                     142              CLR     D6                  
00001176  4CDF 001F                143              MOVEM.L (SP)+,D0-D4             
0000117A  4E75                     144              RTS                         
0000117C                           145          
0000117C                           146  ; Fill the message buffer with address so that the format can be: address DATA hex
0000117C  224A                     147  FILL_ADDRESS: MOVEA.L  A2,A1              *load trap address with A2                     JSR      getLongtLong
0000117E  4EB9 000017FC            148                JSR getLong
00001184  14FC 0009                149                MOVE.B   #$09,(A2)+                                   
00001188  4E75                     150                RTS
0000118A                           151           
0000118A                           152  ; Print stuff in the buffer
0000118A  244E                     153  buffPrep    MOVEA.L A6,A2         
0000118C  61EE                     154              BSR     FILL_ADDRESS        * fill buffer with current address
0000118E  4EB9 000011D0            155              JSR     opDecode
00001194  14BC 0000                156              MOVE.B  #00,(A2)            * null terminater
00001198  103C 000D                157              MOVE.B  #13,D0
0000119C  4E4F                     158              TRAP    #15                 * print decoded Op
0000119E                           159                                
0000119E  B9C8                     160              CMPA.L   A0,A4              * have we reached the end of our address range?
000011A0  6F00 002C                161              BLE      endBuff
000011A4                           162              
000011A4  5247                     163              ADDI    #1,D7               * increment counter
000011A6  BE7C 0014                164              CMP     #printCount,D7
000011AA  66DE                     165              BNE     buffPrep
000011AC                           166              
000011AC  103C 0001                167              MOVE.B  #1,D0
000011B0  43F9 00004068            168              LEA     str_enter,A1
000011B6  3239 00004086            169              MOVE.W  str_en_len,D1
000011BC  4E4F                     170              TRAP    #15
000011BE                           171              
000011BE  103C 0002                172              MOVE.B  #2,D0
000011C2  4E4F                     173              TRAP    #15
000011C4                           174              
000011C4  12BC 0050                175              MOVE.B  #$50,(A1)
000011C8                           176              
000011C8  4247                     177              CLR     D7                  *reset counter
000011CA  4EF8 118A                178              JMP     buffPrep
000011CE                           179              
000011CE  4E75                     180  endBuff     RTS         
000011D0                           181            
000011D0  48E7 FB0E                182  opDecode    MOVEM.L A4-A6/D0-D4/D6-D7,-(SP)      * Save registers
000011D4  4EB9 000018FC            183              JSR     clrRegs             * Clear registers for use
000011DA  1A3C 0001                184              MOVE.B  #1,D5        * Set good flag until fail
000011DE  3E18                     185              MOVE.W  (A0)+,D7            * Move instruction to D7 & Increment pointer
000011E0  264A                     186              MOVEA.L A2,A3               * Store buffer location                 
000011E2  4EB9 000011EE            187              JSR     getOp               * Decode instruction Test
000011E8                           188  
000011E8                           189  
000011E8                           190  
000011E8                           191  ********************************************************************************************************************** 
000011E8                           192  * Start of opReturn section - clean up process and return to IO
000011E8                           193  ********************************************************************************************************************** 
000011E8  4CDF 70DF                194  opReturn    MOVEM.L (SP)+,D6-D7/D0-D4/A4-A6 
000011EC  4E75                     195              RTS              
000011EE                           196              
000011EE                           197                                      
000011EE  3C07                     198  getOp       MOVE.W  D7,D6               * Move instruction to shift
000011F0  183C 000C                199              MOVE.B  #shift12bits,D4         * Load shifter register
000011F4  E86E                     200              LSR.W   D4,D6               * Shift right 12 bits
000011F6  CCFC 0006                201              MULU    #6,D6               * Form offset           
000011FA  4BF9 00001206            202              LEA     tbl_op,A5           * Index into the table                                                                                   
00001200  4EB5 6000                203              JSR     00(A5,D6)           * Jump indirect with index (00 indicates word movement)
00001204  4E75                     204              RTS
00001206                           205  
00001206                           206  
00001206                           207  
00001206                           208  ********************************************************************************************************************** 
00001206                           209  * Beginning of the main table: tbl_op
00001206                           210  * Contains the functions per the first 4 bits of current instruction.
00001206                           211  ********************************************************************************************************************** 
00001206                           212  tbl_op      
00001206  4EF9 0000124E            213              JMP     hex1_0000            
0000120C  4EF9 000012A8            214              JMP     hex1_0001            
00001212                           215              ;JMP     hex1_0010
00001212  4EF9 0000130E            216              JMP     hex1_0011
00001218  4EF9 000013C8            217              JMP     hex1_0100
0000121E  4EF9 0000142C            218              JMP     hex1_0101
00001224  4EF9 00001434            219              JMP     hex1_0110
0000122A  4EF9 0000143E            220              JMP     hex1_0111
00001230                           221              ;JMP     hex1_1000
00001230  4EF9 00001446            222              JMP     hex1_1001
00001236  4EF9 00001504            223              JMP     hex1_1010
0000123C  4EF9 0000150C            224              JMP     hex1_1011
00001242  4EF9 000015C0            225              JMP     hex1_1100
00001248  4EF9 000015F0            226              JMP     hex1_1101
0000124E                           227              ;JMP     hex1_1110
0000124E                           228              ;JMP     hex1_1111
0000124E                           229  
0000124E                           230  ********************************************************************************************************************** 
0000124E                           231  * Case for: first four bits = 0000
0000124E                           232  * --(ORI) 
0000124E                           233  ********************************************************************************************************************** 
0000124E  3C07                     234  hex1_0000   MOVE.W  D7,D6               * Fresh copy of instruction to shift
00001250  0246 0F00                235              ANDI.W  #$0F00,D6           * Isolate second byte
00001254  183C 0008                236              MOVE.B  #shift8bits,D4          * Load shifter
00001258  E8AE                     237              LSR.L   D4,D6               * Shift to LSB
0000125A  BC3C 0000                238              CMP.B   #$0,D6              * Is this ORI?
0000125E  6700 0006                239              BEQ     opORI               * Jump to opORI section
00001262  6600 062C                240              BNE     badInst             * No - bad instruction                  
00001266                           241  
00001266  14FC 004F                242  opORI       MOVE.B  #'O',(A2)+          * Populate ORI into buffer
0000126A  14FC 0052                243              MOVE.B  #'R',(A2)+
0000126E  14FC 0049                244              MOVE.B  #'I',(A2)+
00001272  14FC 002E                245              MOVE.B  #'.',(A2)+
00001276  4EB9 00001790            246              JSR     size2Buffer         * determine & add size to buffer
0000127C  14FC 0020                247              MOVE.B  #' ',(A2)+
00001280  14FC 0020                248              MOVE.B  #' ',(A2)+
00001284  14FC 0020                249              MOVE.B  #' ',(A2)+
00001288  14FC 0020                250              MOVE.B  #' ',(A2)+            
0000128C  14FC 0023                251              MOVE.B  #'#',(A2)+            
00001290  4EB9 000017E2            252              JSR     getAddr             * Add immediate source
00001296  14FC 002C                253              MOVE.B  #',',(A2)+          * Add comma
0000129A  4EB9 00001924            254              JSR     getEA               * Print off desitination operand
000012A0  4EF9 000012A6            255              JMP     end0000             * Skip to end of sub: hex1_0000
000012A6                           256  
000012A6  4E75                     257  end0000     RTS
000012A8                           258  ********************************************************************************************************************** 
000012A8                           259  * Case for: first four bits = 0011                                   
000012A8                           260  * MOVE.B
000012A8                           261  ********************************************************************************************************************** 
000012A8                           262  
000012A8                           263  *hex1_0011  MOVE.B  #'M',(A2)+          * Start of MOVE.B OpCode
000012A8                           264  *            MOVE.B  #'O',(A2)+
000012A8                           265  *            MOVE.B  #'V',(A2)+
000012A8                           266  *            MOVE.B  #'E',(A2)+
000012A8                           267  *            MOVE.B  #'.',(A2)+
000012A8                           268  *            MOVE.B  #'B',(A2)+
000012A8                           269  *            MOVE.B  #' ',(A2)+
000012A8                           270  *            MOVE.B  #' ',(A2)+
000012A8                           271  *            MOVE.B  #' ',(A2)+  
000012A8                           272  *            JSR     getEA               * get source destination
000012A8                           273  *            MOVE.B  #',',(A2)+
000012A8                           274  *            JSR     swap4Move           * swap destination and source regs for getEA
000012A8                           275  *            JSR     getEA     
000012A8                           276  *end0001     RTS 
000012A8                           277  *            
000012A8                           278              
000012A8                           279              
000012A8                           280              
000012A8                           281  ********************************************************************************************************************** 
000012A8                           282  * Case for: first four bits = 0001                                 
000012A8                           283  * MOVE.L, MOVEA.L
000012A8                           284  ********************************************************************************************************************** 
000012A8  14FC 004D                285  hex1_0001   MOVE.B  #'M',(A2)+          * Start of MOVE/A.L OpCodes
000012AC  14FC 004F                286              MOVE.B  #'O',(A2)+
000012B0  14FC 0056                287              MOVE.B  #'V',(A2)+
000012B4  14FC 0045                288              MOVE.B  #'E',(A2)+
000012B8  1C07                     289              MOVE.B  D7,D6               * copy fresh instruction to Shift
000012BA  EC8E                     290              LSR.L   #6,D6               * shift by 6 to isolate bits 6-8 in LSB
000012BC  0246 0007                291              ANDI.W  #$07,D6             * determine if MoveA?
000012C0  BC3C 0001                292              CMP.B   #$1,D6              * is this a MOVEA Function?
000012C4  6600 001C                293              BNE     moveL               * no then move to . portion
000012C8  14FC 0041                294              MOVE.B  #'A',(A2)+
000012CC  14FC 002E                295              MOVE.B  #'.',(A2)+
000012D0  14FC 004C                296              MOVE.B  #'L',(A2)+
000012D4  14FC 0020                297              MOVE.B  #' ',(A2)+
000012D8  14FC 0020                298              MOVE.B  #' ',(A2)+
000012DC  4EF9 000012F6            299              JMP     moveLEA             * skip to filling out source destination
000012E2  14FC 002E                300  moveL       MOVE.B  #'.',(A2)+
000012E6  14FC 004C                301              MOVE.B  #'L',(A2)+
000012EA  14FC 0020                302              MOVE.B  #' ',(A2)+
000012EE  14FC 0020                303              MOVE.B  #' ',(A2)+
000012F2  14FC 0020                304              MOVE.B  #' ',(A2)+  
000012F6  4EB9 00001924            305  moveLEA     JSR     getEA               * get source destination
000012FC  14FC 002C                306              MOVE.B  #',',(A2)+
00001300  4EB9 00001374            307              JSR     swapDestReg  * swap destination and source regs for getEA
00001306  4EB9 00001924            308              JSR     getEA     
0000130C  4E75                     309  end0010     RTS
0000130E                           310   
0000130E                           311   
0000130E                           312   
0000130E                           313  ********************************************************************************************************************** 
0000130E                           314  * Case for: first four bits = 0011                                    
0000130E                           315  * MOVE.W, MOVEA.W
0000130E                           316  ********************************************************************************************************************** 
0000130E  14FC 004D                317  hex1_0011   MOVE.B  #'M',(A2)+          * Start of MOVE/A.W OpCodes
00001312  14FC 004F                318              MOVE.B  #'O',(A2)+
00001316  14FC 0056                319              MOVE.B  #'V',(A2)+
0000131A  14FC 0045                320              MOVE.B  #'E',(A2)+
0000131E  1C07                     321              MOVE.B  D7,D6               * copy fresh instruction to Shift
00001320  EC8E                     322              LSR.L   #6,D6               * shift by 6 to isolate bits 6-8 in LSB
00001322  0246 0007                323              ANDI.W  #$07,D6             * determin if move A?
00001326  BC3C 0001                324              CMP.B   #$1,D6              * is this a MOVEA Function?
0000132A  6600 001C                325              BNE     moveW               * no then move to . portion
0000132E  14FC 0041                326              MOVE.B  #'A',(A2)+          * yes - populate A
00001332  14FC 002E                327              MOVE.B  #'.',(A2)+
00001336  14FC 0057                328              MOVE.B  #'W',(A2)+
0000133A  14FC 0020                329              MOVE.B  #' ',(A2)+
0000133E  14FC 0020                330              MOVE.B  #' ',(A2)+
00001342  4EF9 0000135C            331              JMP     moveWEA             * skip to filling out source destination
00001348  14FC 002E                332  moveW       MOVE.B  #'.',(A2)+
0000134C  14FC 0057                333              MOVE.B  #'W',(A2)+
00001350  14FC 0020                334              MOVE.B  #' ',(A2)+
00001354  14FC 0020                335              MOVE.B  #' ',(A2)+
00001358  14FC 0020                336              MOVE.B  #' ',(A2)+  
0000135C  4EB9 00001924            337  moveWEA     JSR     getEA               * get source destination
00001362  14FC 002C                338              MOVE.B  #',',(A2)+
00001366  4EB9 00001374            339              JSR     swapDestReg  * swap destination and source regs for getEA
0000136C  4EB9 00001924            340              JSR     getEA     
00001372  4E75                     341  end0011     RTS 
00001374                           342  
00001374                           343  
00001374                           344  
00001374  4283                     345  swapDestReg CLR.L   D3                  * Clear (0000) D3 to hold swap value
00001376  3C07                     346              MOVE.W  D7,D6               * Copy to initial shift get reg bits 9-11
00001378  E04E                     347              LSR.W   #shift8bits,D6          * shift by 8 (9 total)
0000137A  E24E                     348              LSR.W   #1,D6               * shift by 1 (9 total)
0000137C  0246 0007                349              ANDI.W  #$0007,D6           * Mask/Isolate last 3 bits
00001380  8646                     350              OR.W    D6,D3               * Place Reg Bits Into D3 for swap
00001382  3C07                     351              MOVE.W  D7,D6               * Copy to get mode bits 6-8
00001384  E64E                     352              LSR.W   #3,D6               * shift bits 6-8 down 3 to normal ea position 3-5
00001386  0246 0038                353              ANDI.W  #$0038,D6           * mask bits 3-5
0000138A  8646                     354              OR.W    D6,D3               * add the move bits into D3
0000138C  4EB9 00001396            355              JSR     moveSize            * add the move size bits (6-7) into D3 for ea
00001392  3E03                     356              MOVE.W  D3,D7               * swap register mode to determine destination from ea functions
00001394  4E75                     357              RTS
00001396                           358              
00001396                           359              
00001396  3C07                     360  moveSize    MOVE.W  D7,D6               * get fresh copy to determine MOVE size
00001398  E04E                     361              LSR.W   #shift8bits,D6          * shift move size bits 12-13 to LSB
0000139A  E84E                     362              LSR.W   #shift4bits,D6          
0000139C  0246 0003                363              ANDI.W  #$0003,D6           * Isolate move bits
000013A0  BC3C 0001                364              CMP.B   #$1,D6              * is this a byte?
000013A4  6700 0020                365              BEQ     mSizeEnd            * yes - byte size already in bits 6-7 of D3
000013A8  BC3C 0002                366              CMP.B   #$2,D6              * is this a L?
000013AC  6700 0014                367              BEQ     moveSizeL           * yes - Or L size to D3 bits 6-7
000013B0  BC3C 0003                368              CMP.B   #$3,D6              * is this a W?
000013B4  6600 04DA                369              BNE     badInst             * No- then badInst        
000013B8  0043 0040                370  moveSizeW   ORI.W   #$0040,D3           * add size 01 in bits 6-7 (4) into D3
000013BC  4EF9 000013C6            371              JMP     mSizeEnd            * skip to end once done
000013C2  0043 0080                372  moveSizeL   ORI.W   #$0080,D3           * add size 10 in bits 6-7 (4) into D3
000013C6  4E75                     373  mSizeEnd    RTS 
000013C8                           374  
000013C8                           375  
000013C8                           376  
000013C8                           377  ********************************************************************************************************************** 
000013C8                           378  * Case for: first four bits = 0100
000013C8                           379  * --(MOVEM,LEA,NOP)
000013C8                           380  ********************************************************************************************************************** 
000013C8  3C07                     381  hex1_0100   MOVE.W  D7,D6               * Fresh copy of instruction to shift
000013CA  0246 0100                382              ANDI.W  #$0100,D6           * Test isolate 8th bit for LEA
000013CE  BC7C 0100                383              CMP.W   #$0100,D6           * Test if LEA
000013D2  6700 0022                384              BEQ     opLEA               * Yes finish testing for LEA
000013D6  3C07                     385              MOVE.W  D7,D6               * Copy fresh copy of instruction to shift
000013D8  183C 0008                386              MOVE.B  #shift8bits,D4          * Load 8 bit shifter
000013DC  E86E                     387              LSR.W   D4,D6               * Shift current instruction
000013DE  0246 000F                388              ANDI.W  #$000F,D6           * Isolate last 4 bits (LSB)
000013E2  CCFC 0006                389              MULU    #6,D6               * Form offset for next JMP table
000013E6  4BF9 000016AE            390              LEA     tbl_0100,A5         * Load next JMP table 
000013EC  4EB5 6000                391              JSR     00(A5,D6)           * Jump to next instruction per next 4 bits
000013F0  4EF9 0000142A            392              JMP     end0100             * Once returned from jump table, skip to end
000013F6                           393              
000013F6  14FC 004C                394  opLEA       MOVE.B  #'L',(A2)+          * Start input of LEA
000013FA  14FC 0045                395              MOVE.B  #'E',(A2)+
000013FE  14FC 0041                396              MOVE.B  #'A',(A2)+
00001402  14FC 0020                397              MOVE.B  #' ',(A2)+
00001406  14FC 0009                398              MOVE.B  #$09,(A2)+ 
0000140A  4EB9 00001924            399              JSR     getEA               * Determine address to go to buffer
00001410  14FC 002C                400              MOVE.B  #',',(A2)+          * Add comma
00001414  14FC 0041                401              MOVE.B  #'A',(A2)+          * Add A(x)
00001418  3C07                     402              MOVE.W  D7,D6               * Copy fresh copy of instruction to shift
0000141A  183C 0009                403              MOVE.B  #9,D4               * Load 9 bit shifter
0000141E  E86E                     404              LSR.W   D4,D6               * Shift current instruction
00001420  0246 000F                405              ANDI.W  #$000F,D6           * Isolate last 4 bits (LSB)
00001424  0606 0030                406              ADD.B   #$30,D6             * convert data register # to hex digit
00001428  14C6                     407              MOVE.B  D6,(A2)+            * register # to buffer
0000142A  4E75                     408  end0100     RTS
0000142C                           409  
0000142C  4EB9 00001890            410  hex1_0101   JSR     badInst             * Invalid Instruction
00001432  4E75                     411              RTS
00001434                           412              
00001434                           413              ***** MOVEM Command
00001434  4EB9 00001890            414  hex1_0110   JSR     badInst
0000143A  5448                     415              ADDQ.W  #2,A0
0000143C  4E75                     416              RTS
0000143E                           417  
0000143E  4EB9 00001890            418  hex1_0111   JSR     badInst             * Invalid Instruction
00001444  4E75                     419              RTS
00001446                           420             
00001446                           421  
00001446                           422  
00001446                           423  ********************************************************************************************************************** 
00001446                           424  * Case for: first four bits = 1001
00001446                           425  * --(SUB,SUBA) - Need to look into possibilites with immediate
00001446                           426  ********************************************************************************************************************** 
00001446  14FC 0053                427  hex1_1001   MOVE.B  #'S',(A2)+          * Put ADD into Buff
0000144A  14FC 0055                428              MOVE.B  #'U',(A2)+
0000144E  14FC 0042                429              MOVE.B  #'B',(A2)+
00001452  4EB9 00001786            430              JSR     getSize             * return size  in 6 & 7 into D6
00001458  BC3C 0003                431              CMP.B   #%11,D6             * determine if a ADD or ADDA
0000145C  6600 004E                432              BNE     opSUB               * not size 11, then skip to ADD
00001460  14FC 0041                433              MOVE.B  #'A',(A2)+          * yep, detected 11 then ADDA
00001464  14FC 002E                434              MOVE.B  #'.',(A2)+
00001468  3C07                     435              MOVE.W  D7,D6               * fresh copy of instruction
0000146A  E08E                     436              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
0000146C  0246 0001                437              ANDI.W  #$0001,D6           * Isolate last bit for size
00001470  BC3C 0001                438              CMP.B   #%1,D6              * compare for a 1 to determine
00001474  6700 000C                439              BEQ     subaL               * jump to long, else word
00001478  14FC 0057                440              MOVE.B  #'W',(A2)+          * add word size into buffer
0000147C  4EF9 00001486            441              JMP     opSUBA
00001482  14FC 004C                442  subaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
00001486  14FC 0020                443  opSUBA      MOVE.B  #' ',(A2)+
0000148A  14FC 0020                444              MOVE.B  #' ',(A2)+
0000148E  14FC 0020                445              MOVE.B  #' ',(A2)+
00001492                           446              **** NOTE NEED TO TEST FOR EA to ADD $
00001492  4EB9 00001924            447              JSR     getEA               * get source operand
00001498  14FC 002C                448              MOVE.B  #',',(A2)+
0000149C  14FC 0041                449              MOVE.B  #'A',(A2)+  
000014A0  4EB9 000017C6            450              JSR     highRegBits         * Add register number to buffer
000014A6  4EF9 000016AC            451              JMP     end1101
000014AC                           452              
000014AC  14FC 002E                453  opSUB       MOVE.B  #'.',(A2)+          * finish putting Add.x to buffer
000014B0  4EB9 00001790            454              JSR     size2Buffer         * Determine Size and Add to Buffer
000014B6  14FC 0020                455              MOVE.B  #' ',(A2)+
000014BA  14FC 0020                456              MOVE.B  #' ',(A2)+
000014BE  14FC 0020                457              MOVE.B  #' ',(A2)+
000014C2  14FC 0020                458              MOVE.B  #' ',(A2)+
000014C6  4EB9 000017D8            459              JSR     getDirBit           * get Direction Bit 0 = EA 1 =regs
000014CC  BC3C 0000                460              CMP.B   #%0,D6              * is this EA first?
000014D0  6600 001C                461              BNE     opSUB01             * no, jmp to reg mode first
000014D4  4EB9 00001924            462              JSR     getEA               * print off effective address
000014DA  14FC 002C                463              MOVE.B  #',',(A2)+          * add comma
000014DE  14FC 0044                464              MOVE.B  #'D',(A2)+          * add register BAM!
000014E2  4EB9 000017C6            465              JSR     highRegBits         * Add register number to buffer
000014E8  4EF9 00001502            466              JMP     end1001             * jump to exit of sub: hex1_1101
000014EE                           467              
000014EE  14FC 0044                468  opSUB01     MOVE.B  #'D',(A2)+          * start register entry
000014F2  4EB9 000017C6            469              JSR     highRegBits         * add register number
000014F8  14FC 002C                470              MOVE.B  #',',(A2)+          * add comma
000014FC  4EB9 00001924            471              JSR     getEA               * finish with EA          
00001502                           472              
00001502  4E75                     473  end1001     RTS            
00001504                           474  
00001504  4EB9 00001890            475  hex1_1010   JSR     badInst             * Invalid Instruction
0000150A  4E75                     476              RTS
0000150C                           477  
0000150C                           478  
0000150C                           479  
0000150C                           480  ********************************************************************************************************************** 
0000150C                           481  * Case for: first four bits = 1011
0000150C                           482  * --(CMP)
0000150C                           483  ********************************************************************************************************************** 
0000150C  4EB9 00001786            484  hex1_1011   JSR     getSize             * return size  in 6 & 7 into D6
00001512  BC3C 0003                485              CMP.B   #%11,D6             * determine if a CMPA
00001516  6600 005A                486              BNE     opCMPEOR
0000151A  14FC 0043                487              MOVE.B  #'C',(A2)+          * Put SUBA into Buff
0000151E  14FC 004D                488              MOVE.B  #'M',(A2)+
00001522  14FC 0050                489              MOVE.B  #'P',(A2)+
00001526  14FC 0041                490              MOVE.B  #'A',(A2)+
0000152A  14FC 002E                491              MOVE.B  #'.',(A2)+
0000152E  3C07                     492              MOVE.W  D7,D6               * fresh copy of instruction
00001530  E08E                     493              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
00001532  0246 0001                494              ANDI.W  #$0001,D6           * Isolate last bit for size
00001536  BC3C 0001                495              CMP.B   #%1,D6              * compare for a 1 to determine
0000153A  6700 000C                496              BEQ     cmpaL               * jump to long, else word
0000153E  14FC 0057                497              MOVE.B  #'W',(A2)+          * add word size into buffer
00001542  4EF9 0000154C            498              JMP     opCMPA              * Skip to adding padding and destination
00001548  14FC 004C                499  cmpaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
0000154C  14FC 0020                500  opCMPA      MOVE.B  #' ',(A2)+
00001550  14FC 0020                501              MOVE.B  #' ',(A2)+
00001554  14FC 0020                502              MOVE.B  #' ',(A2)+
00001558                           503  
00001558  4EB9 00001924            504              JSR     getEA               * get source operand
0000155E  14FC 002C                505              MOVE.B  #',',(A2)+
00001562  14FC 0041                506              MOVE.B  #'A',(A2)+
00001566  4EB9 000017C6            507              JSR     highRegBits         * Get address register number
0000156C  4EF9 000015BE            508              JMP     end1011             * Skip to end of sub: hex1_1011
00001572                           509              
00001572  3C07                     510  opCMPEOR    MOVE.W  D7,D6               * fresh value
00001574  4EB9 000017D8            511              JSR     getDirBit           * determine the direction bit 1 = eor 0 = cmp
0000157A  BC3C 0000                512              CMP.B   #%0,D6              * yes, go into CMP     
0000157E                           513                     
0000157E  14FC 0043                514  opCMP       MOVE.B  #'C',(A2)+          * Populate CMP
00001582  14FC 004D                515              MOVE.B  #'M',(A2)+
00001586  14FC 0050                516              MOVE.B  #'P',(A2)+
0000158A  14FC 002E                517              MOVE.B  #'.',(A2)+
0000158E  4EB9 00001790            518              JSR     size2Buffer         * Determine & add size to buffer
00001594  14FC 0020                519              MOVE.B  #' ',(A2)+
00001598  14FC 0020                520              MOVE.B  #' ',(A2)+
0000159C  14FC 0020                521              MOVE.B  #' ',(A2)+
000015A0  14FC 0020                522              MOVE.B  #' ',(A2)+
000015A4  4EB9 00001924            523              JSR     getEA               * Source Operand
000015AA  14FC 002C                524              MOVE.B  #',',(A2)+
000015AE  14FC 0044                525              MOVE.B  #'D',(A2)+  
000015B2  4EB9 000017C6            526              JSR     highRegBits         * Add register number to buffer
000015B8  4EF9 000015BE            527              JMP     end1011             * Skip to end of sub: hex1_1011
000015BE                           528        
000015BE                           529  
000015BE  4E75                     530  end1011     RTS
000015C0                           531  
000015C0                           532  
000015C0                           533  
000015C0                           534  
000015C0                           535  ********************************************************************************************************************** 
000015C0                           536  * Case for: first four bits = 1100
000015C0                           537  * MULU
000015C0                           538  ********************************************************************************************************************** 
000015C0  3C07                     539  hex1_1100   MOVE.W  D7,D6               * copy instruction for testing
000015C2  EC8E                     540  opMULU      LSR.L   #6,D6               * shift 6 to prep for mulu testing
000015C4  0246 0003                541              ANDI.W  #$3,D6              * mask last 3 bits
000015C8  BC3C 0003                542              CMP.B   #$3,D6              * is this MULU or MULS?
000015CC  6700 0002                543              BEQ     muluMode            * head to mulu  mode to determine immediate  
000015D0  3C07                     544  muluMode    MOVE.W  D7,D6               * fresh copy
000015D2  E68E                     545              LSR.L   #3,D6               * shift bits 3-5 into LSB
000015D4  0246 0007                546              ANDI.W  #$7,D6              * mask for mode bits
000015D8  BC3C 0007                547              CMP.B   #$7,D6              *
000015DC  6700 0008                548              BEQ     movePTR             * increment pointer by word
000015E0  4EF9 00001890            549              JMP     badInst     
000015E6                           550  
000015E6  5448                     551  movePTR     ADDQ.W  #2,A0               * increment pointer
000015E8  4EF9 00001890            552              JMP     badInst
000015EE                           553          
000015EE                           554  
000015EE  4E75                     555  end1100     RTS
000015F0                           556  
000015F0                           557  ********************************************************************************************************************** 
000015F0                           558  * Case for: first four bits = 1101
000015F0                           559  * --(ADD,ADDA)
000015F0                           560  ********************************************************************************************************************** 
000015F0  14FC 0041                561  hex1_1101   MOVE.B  #'A',(A2)+          * Put ADD into Buff
000015F4  14FC 0044                562              MOVE.B  #'D',(A2)+
000015F8  14FC 0044                563              MOVE.B  #'D',(A2)+
000015FC  4EB9 00001786            564              JSR     getSize             * return size  in 6 & 7 into D6
00001602  BC3C 0003                565              CMP.B   #%11,D6             * determine if a ADD or ADDA
00001606  6600 004E                566              BNE     opADD               * not size 11, then skip to ADD
0000160A  14FC 0041                567              MOVE.B  #'A',(A2)+          * yep, detected 11 then ADDA
0000160E  14FC 002E                568              MOVE.B  #'.',(A2)+
00001612  3C07                     569              MOVE.W  D7,D6               * fresh copy of instruction
00001614  E08E                     570              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
00001616  0246 0001                571              ANDI.W  #$0001,D6           * Isolate last bit for size
0000161A  BC3C 0001                572              CMP.B   #%1,D6              * compare for a 1 to determine
0000161E  6700 000C                573              BEQ     addaL               * jump to long, else word
00001622  14FC 0057                574              MOVE.B  #'W',(A2)+          * add word size into buffer
00001626  4EF9 00001630            575              JMP     opADDA
0000162C  14FC 004C                576  addaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
00001630  14FC 0020                577  opADDA      MOVE.B  #' ',(A2)+
00001634  14FC 0020                578              MOVE.B  #' ',(A2)+
00001638  14FC 0020                579              MOVE.B  #' ',(A2)+
0000163C                           580              **** NOTE NEED TO TEST FOR EA to ADD $
0000163C  4EB9 00001924            581              JSR     getEA               * get source operand
00001642  14FC 002C                582              MOVE.B  #',',(A2)+
00001646  14FC 0041                583              MOVE.B  #'A',(A2)+  
0000164A  4EB9 000017C6            584              JSR     highRegBits         * Add register number to buffer
00001650  4EF9 000016AC            585              JMP     end1101
00001656                           586              
00001656  14FC 002E                587  opADD       MOVE.B  #'.',(A2)+          * finish putting Add.x to buffer
0000165A  4EB9 00001790            588              JSR     size2Buffer         * Determine Size and Add to Buffer
00001660  14FC 0020                589              MOVE.B  #' ',(A2)+
00001664  14FC 0020                590              MOVE.B  #' ',(A2)+
00001668  14FC 0020                591              MOVE.B  #' ',(A2)+
0000166C  14FC 0020                592              MOVE.B  #' ',(A2)+
00001670  4EB9 000017D8            593              JSR     getDirBit           * get Direction Bit 0 = EA 1 =regs
00001676  BC3C 0000                594              CMP.B   #%0,D6              * is this EA first?
0000167A  6600 001C                595              BNE     opADD01             * no, jmp to reg mode first
0000167E  4EB9 00001924            596              JSR     getEA               * print off effective address
00001684  14FC 002C                597              MOVE.B  #',',(A2)+          * add comma
00001688  14FC 0044                598              MOVE.B  #'D',(A2)+          * add register BAM!
0000168C  4EB9 000017C6            599              JSR     highRegBits         * Add register number to buffer
00001692  4EF9 000016AC            600              JMP     end1101             * jump to exit of sub: hex1_1101
00001698                           601              
00001698  14FC 0044                602  opADD01     MOVE.B  #'D',(A2)+          * start register entry
0000169C  4EB9 000017C6            603              JSR     highRegBits         * add register number
000016A2  14FC 002C                604              MOVE.B  #',',(A2)+          * add comma
000016A6  4EB9 00001924            605              JSR     getEA               * finish with EA 
000016AC                           606  
000016AC  4E75                     607  end1101     RTS
000016AE                           608  
000016AE                           609  
000016AE                           610  
000016AE                           611  ********************************************************************************************************************** 
000016AE                           612  * Beginning of 4xxx Op Codes table: tbl_0100 
000016AE                           613  * Contains the functions per the second  4 bits of current instruction.
000016AE                           614  ********************************************************************************************************************** 
000016AE                           615  tbl_0100    *Jump table for all op codes that start with 4XXX
000016AE  4EF9 000016F6            616              JMP     hex4_0000            
000016B4  4EF9 000016FE            617              JMP     hex4_0001            
000016BA                           618              ;JMP     hex4_0010
000016BA                           619              ;JMP     hex4_0011
000016BA                           620              ;JMP     hex4_0100
000016BA  4EF9 0000170E            621              JMP     hex4_0101
000016C0                           622              ;JMP     hex4_0110
000016C0  4EF9 00001716            623              JMP     hex4_0111
000016C6  4EF9 0000171E            624              JMP     hex4_1000
000016CC  4EF9 00001738            625              JMP     hex4_1001
000016D2  4EF9 00001740            626              JMP     hex4_1010
000016D8  4EF9 00001748            627              JMP     hex4_1011
000016DE  4EF9 00001750            628              JMP     hex4_1100
000016E4  4EF9 00001758            629              JMP     hex4_1101
000016EA  4EF9 00001768            630              JMP     hex4_1110
000016F0  4EF9 00001760            631              JMP     hex4_1111
000016F6                           632              
000016F6  4EB9 00001890            633  hex4_0000   JSR     badInst
000016FC  4E75                     634              RTS
000016FE                           635              
000016FE  4EB9 00001890            636  hex4_0001   JSR     badInst
00001704  4E75                     637              RTS
00001706                           638              
00001706  4EB9 00001890            639  hex4_0011   JSR     badInst
0000170C  4E75                     640              RTS
0000170E                           641                            
0000170E                           642              
0000170E  4EB9 00001890            643  hex4_0101   JSR     badInst
00001714  4E75                     644              RTS
00001716                           645          
00001716                           646              
00001716  4EB9 00001890            647  hex4_0111   JSR     badInst
0000171C  4E75                     648              RTS
0000171E                           649              
0000171E                           650              
0000171E                           651  ********************************************************************************************************************** 
0000171E                           652  * Case for: 0100 1000 (MOVEM)                                                          
0000171E                           653  ********************************************************************************************************************** 
0000171E  3C07                     654  hex4_1000   MOVE.W  D7,D6           * copy instruction
00001720  E88E                     655              LSR.L   #shift4bits,D6      * shift by 4 bits
00001722  0246 000F                656              ANDI.W  #$000F,D6       * isolate last byte
00001726  BC3C 0004                657              CMP.B   #$4,D6          * Determine if SWAP
0000172A  6600 0004                658              BNE     opMOVEM         * No - go to MOVEM
0000172E                           659  
0000172E  4E75                     660              RTS            
00001730                           661  
00001730  4EB9 00001890            662  opMOVEM     JSR     badInst
00001736  4E75                     663              RTS   
00001738                           664  
00001738  4EB9 00001890            665  hex4_1001   JSR     badInst
0000173E  4E75                     666              RTS   
00001740  4EB9 00001890            667  hex4_1010   JSR     badInst
00001746  4E75                     668              RTS   
00001748  4EB9 00001890            669  hex4_1011   JSR     badInst
0000174E  4E75                     670              RTS
00001750  4EB9 00001890            671  hex4_1100   JSR     badInst
00001756  4E75                     672              RTS
00001758  4EB9 00001890            673  hex4_1101   JSR     badInst
0000175E  4E75                     674              RTS
00001760  4EB9 00001890            675  hex4_1111   JSR     badInst
00001766  4E75                     676              RTS   
00001768                           677  
00001768                           678  
00001768                           679  ********************************************************************************************************************** 
00001768                           680  * Case for: 0100 1110 (NOP)                                                      
00001768                           681  ********************************************************************************************************************** 
00001768  4EB9 00001786            682  hex4_1110   JSR     getSize             * determine the size for (JSR,JMP)
0000176E  BC3C 0002                683              CMP.B   #%10,D6             * test size bits is this JSR? (0100 1110 10..)
00001772  6600 011C                684              BNE     badInst             * No set badFlag for illegal instruction
00001776                           685               
00001776  14FC 004E                686              MOVE.B  #'N',(A2)+          * yes - print NOP to goodBuff
0000177A  14FC 004F                687              MOVE.B  #'O',(A2)+
0000177E  14FC 0050                688              MOVE.B  #'P',(A2)+
00001782  4E75                     689              RTS
00001784                           690  
00001784                           691              
00001784  4E75                     692  hex2_1111   RTS    
00001786                           693  
00001786                           694  
00001786                           695  ********************************************************************************************************************** 
00001786                           696  * Beginning of functions: badInst, getSize, size2Buffer, 
00001786                           697  ********************************************************************************************************************** 
00001786  3C07                     698  getSize     MOVE.W  D7,D6               * copy current instruction to shift
00001788  EC4E                     699              LSR.W   #6,D6               * move the size bits in 6-7 to LSB
0000178A  0246 0003                700              ANDI.W  #$0003,D6           * remove other non-size bits and store result into D6
0000178E  4E75                     701              RTS
00001790                           702  
00001790  4EB8 1786                703  size2Buffer JSR     getSize             * run sizing Commands
00001794  BC3C 0000                704              CMP.B   #%00,D6             * is tihs a byte?
00001798  6700 001C                705              BEQ     mainB               * yes, add B to buffer
0000179C  BC3C 0001                706              CMP.B   #%01,D6             * is this a word?
000017A0  6700 001E                707              BEQ     mainW               * yes, add teh W to buffer
000017A4  BC3C 0002                708              CMP.B   #%10,D6             * is this a long?
000017A8  6600 00E6                709              BNE     badInst             * No? then bad instruction
000017AC                           710        
000017AC  14FC 004C                711              MOVE.B  #'L',(A2)+          * add L to buffer
000017B0  4EF9 000017C4            712              JMP     mainEnd             * end size2Buffer sub  
000017B6                           713              
000017B6  14FC 0042                714  mainB       MOVE.B  #'B',(A2)+          * add B to buffer
000017BA  4EF9 000017C4            715              JMP     mainEnd             * end size2Buffer sub
000017C0                           716              
000017C0  14FC 0057                717  mainW       MOVE.B  #'W',(A2)+          * add W to buffer
000017C4  4E75                     718  mainEnd     RTS                         * end size2Buffer sub                        
000017C6                           719  
000017C6  3C07                     720  highRegBits MOVE.W  D7,D6               * get fresh copy of instruction
000017C8  E08E                     721              LSR.L   #shift8bits,D6          * shift by 8 (9total)
000017CA  E28E                     722              LSR.L   #1,D6               * shift by 1
000017CC  0206 0007                723              ANDI.B  #$7,D6              * isolate last 7 bits for register number
000017D0  0606 0030                724              ADD.B   #$30,D6             * convert register number to ascii
000017D4  14C6                     725              MOVE.B  D6,(A2)+            * put register numbert into buffer
000017D6  4E75                     726              RTS
000017D8                           727  
000017D8  3C07                     728  getDirBit   MOVE.W  D7,D6               * get fresh copy of instruction
000017DA  E08E                     729              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
000017DC  0206 0001                730              ANDI.B  #01,D6              * isolate last bit for testing & return in D6
000017E0  4E75                     731              RTS  
000017E2                           732              
000017E2  BC3C 0000                733  getAddr     CMP.B   #%00,D6             * test if value is a byte - assumes D6 already loaded
000017E6  6700 025C                734              BEQ     byte2Buffer         * yes? - load B worth of address into buffer
000017EA  BC3C 0001                735              CMP.B   #%01,D6             * test if value is a word - assumes D6 already loaded
000017EE  6700 0282                736              BEQ     word2Buffer         * yes? - load W worth of address into buffer
000017F2  BC3C 0002                737              CMP.B   #%10,D6             * test if value is a long - assumes D6 already loaded
000017F6  6700 02AC                738              BEQ     long2Buffer         * yes? - load L worth of address into buffer
000017FA  4E75                     739              RTS
000017FC                           740  
000017FC  4EB9 0000185A            741  getLong     JSR     cmdSh1              * Clear D6 and load value for shift
00001802  183C 000C                742              MOVE.B  #shift12bits,D4         * Load shifter w/12
00001806  4EB9 00001862            743              JSR     cmdSh2              * Shift
0000180C  183C 0008                744              MOVE.B  #shift8bits,D4          * Load shifter w/8
00001810  4EB9 00001862            745              JSR     cmdSh2              * Shift
00001816  183C 0004                746              MOVE.B  #shift4bits,D4          * Load shifter w/4
0000181A  4EB9 00001862            747              JSR     cmdSh2              * Shift
00001820  183C 0000                748              MOVE.B  #0,D4
00001824  4EB9 0000187C            749              JSR     cmdSh4              * Shift
0000182A  183C 000C                750              MOVE.B  #shift12bits,D4         * Load shifter w/12
0000182E  4EB9 0000187C            751              JSR     cmdSh4              * Shift
00001834  183C 0008                752              MOVE.B  #shift8bits,D4          * Load shifter w/8
00001838  4EB9 0000187C            753              JSR     cmdSh4              * Shift
0000183E  183C 0004                754              MOVE.B  #shift4bits,D4          * Load shifter w/4
00001842  4EB9 0000187C            755              JSR     cmdSh4              * Shift
00001848  183C 0000                756              MOVE.B  #0,D4               * Load shifter
0000184C  E8AE                     757              LSR.L   D4,D6               * Shift
0000184E  0286 0000000F            758              ANDI.L  #$0000000F,D6       * Isolate last bit
00001854  4EB9 0000190C            759              JSR     Hex2ASCII           * Place value in D6 into buffer
0000185A                           760  
0000185A  7C00                     761  cmdSh1      MOVEQ   #$0,D6              * Clear D6
0000185C  2C08                     762              MOVE.L  A0,D6               * Load current address to print
0000185E  4846                     763              SWAP    D6                  * Swap high and low word
00001860  4E75                     764              RTS
00001862                           765  
00001862  E8AE                     766  cmdSh2      LSR.L   D4,D6               * Shift
00001864  0286 0000000F            767              ANDI.L  #$0000000F,D6       * Isolate last bit
0000186A  4EB9 0000190C            768              JSR     Hex2ASCII           * Place value in D6 into buffer
00001870  4EB8 185A                769              JSR     cmdSh1              * Reset D6 for next shift
00001874  4E75                     770              RTS
00001876                           771  
00001876  7C00                     772  cmdSh3      MOVEQ   #$0,D6              * Clear D6
00001878  2C08                     773              MOVE.L  A0,D6               * Load current address to print
0000187A  4E75                     774              RTS
0000187C                           775              
0000187C  E8AE                     776  cmdSh4      LSR.L   D4,D6               * Shift
0000187E  0286 0000000F            777              ANDI.L  #$0000000F,D6       * Isolate last bit
00001884  4EB9 0000190C            778              JSR     Hex2ASCII           * Place value in D6 into buffer
0000188A  4EB8 1876                779              JSR     cmdSh3              * Reset D6 for next shift
0000188E  4E75                     780              RTS
00001890                           781              
00001890  1A3C 0000                782  badInst    MOVE.B  #0,D5         * set bad flag
00001894  244B                     783              MOVEA.L A3,A2               * reset the buffer pointer 
00001896  14FC 0044                784              MOVE.B  #'D',(A2)+          * add bad syntax to goodBuff
0000189A  14FC 0041                785              MOVE.B  #'A',(A2)+
0000189E  14FC 0054                786              MOVE.B  #'T',(A2)+
000018A2  14FC 0041                787              MOVE.B  #'A',(A2)+
000018A6  14FC 0009                788              MOVE.B  #$09,(A2)+
000018AA  14FC 0024                789              MOVE.B  #'$',(A2)+          * add in shift/pad
000018AE  4EB9 000018B6            790              JSR     loadDataBuffer          * add the bad word to the buffer
000018B4  4E75                     791              RTS          
000018B6                           792  
000018B6  7C00                     793  loadDataBuffer      MOVEQ   #$0,D6              * clear out D6 to use for copying word
000018B8  3C07                     794                      MOVE.W  D7,D6               * copy word instruction to D6
000018BA  183C 000C                795                      MOVE.B  #shift12bits,D4         * load shifter
000018BE  E8AE                     796                      LSR.L   D4,D6               * Shift D6
000018C0  0246 000F                797                      ANDI.W  #$000F,D6           * isolate last 4 bits
000018C4  4EB9 0000190C            798                      JSR     Hex2ASCII           * add 1st character to buffer
000018CA  3C07                     799                      MOVE.W  D7,D6
000018CC  183C 0008                800                      MOVE.B  #shift8bits,D4
000018D0  E8AE                     801                      LSR.L   D4,D6
000018D2  0246 000F                802                      ANDI.W  #$000F,D6
000018D6  4EB9 0000190C            803                      JSR     Hex2ASCII           * add 2nd character to buffer
000018DC  3C07                     804                      MOVE.W  D7,D6
000018DE  183C 0004                805                      MOVE.B  #shift4bits,D4
000018E2  E8AE                     806                      LSR.L   D4,D6
000018E4  0246 000F                807                      ANDI.W  #$000F,D6
000018E8  4EB9 0000190C            808                      JSR     Hex2ASCII           * add 3rd character to buffer
000018EE  3C07                     809                      MOVE.W  D7,D6
000018F0  0246 000F                810                      ANDI.W  #$000F,D6
000018F4  4EB9 0000190C            811                      JSR     Hex2ASCII           * add 4th character to buffer   
000018FA  4E75                     812                      RTS
000018FC                           813              
000018FC  4280                     814  clrRegs     CLR.L   D0                 
000018FE  4281                     815              CLR.L   D1
00001900  4282                     816              CLR.L   D2
00001902  4283                     817              CLR.L   D3
00001904  4284                     818              CLR.L   D4
00001906  4286                     819              CLR.L   D6
00001908  4287                     820              CLR.L   D7
0000190A  4E75                     821              RTS
0000190C                           822  
0000190C                           823  ; Convert hex to ascii
0000190C  BC3C 000A                824  Hex2ASCII   CMP.B   #$A,D6              * Confirm hex character?
00001910  6C00 000A                825              BGE     letter              * Is it a letter or number?
00001914  0606 0030                826              ADDI.B  #$30,D6             * Convert decimal to ASCII
00001918  6000 0006                827              BRA     write2Buff          * save to good buffer
0000191C  0606 0037                828  letter      ADDI.B  #$37,D6
00001920  14C6                     829  write2Buff  MOVE.B  D6,(A2)+
00001922  4E75                     830              RTS
00001924                           831              
00001924                           832  getEA       
00001924  4BF9 0000194E            833              LEA         ea_mode_table,A5 * load EA_mode jump table
0000192A  4282                     834              CLR.L   D2
0000192C  4283                     835              CLR.L   D3
0000192E  4284                     836              CLR.L   D4           
00001930  4286                     837              CLR.L   D6
00001932  3C07                     838              MOVE.W  D7,D6                 * move word into D6 for manipulation
00001934  0246 003F                839              ANDI.W  #$003F,D6             * leave only the mode bits
00001938  123C 0003                840              MOVE.B      #3,D1                 * Store number of bits we wish to shift            
0000193C  E26E                     841              LSR.W       D1,D6                 * Shift to the Right to isolate mode bits            
0000193E                           842  
0000193E  CCFC 0006                843              MULU      #6,D6            * Form Offset for passing to Jump Index table            
00001942  4EB5 6000                844              JSR         00(A5,D6)          * Now we have the index, back to Index table        
00001946                           845  
00001946  4E75                     846              RTS                                * return from EA routine
00001948                           847          
00001948  4EF9 000040CC            848              JMP         END                    * Return
0000194E                           849  
0000194E                           850  ea_mode_table                             * table holds the different EA modes
0000194E  4EF9 0000197E            851              JMP     EAcode000             * Direct Data Register
00001954  4EF9 00001990            852              JMP     EAcode001             * Direct Address Register
0000195A  4EF9 000019A2            853              JMP     EAcode010             * Indirect Address Register
00001960  4EF9 000019BC            854              JMP     EAcode011             * Indirect Address Register with Post Increment
00001966  4EF9 000019DA            855              JMP     EAcode100             * Indirect Address Register with Pre Decrement
0000196C  4EF9 000019F8            856              JMP     EAcode101             * Indirect Address Register using Index
00001972  4EF9 000019FC            857              JMP     EAcode110             * 
00001978  4EF9 00001A00            858              JMP     EAcode111             * Absolute or Immediate EA
0000197E                           859  
0000197E                           860  EAcode000
0000197E  3C07                     861              MOVE.W      D7,D6                   * move current working word into temp storage
00001980  0246 0007                862              ANDI.W      #$7,D6                  * isolate register bits (last 3)
00001984  14FC 0044                863              MOVE.B      #'D',(A2)+              * add "D" to buffer
00001988  0606 0030                864              ADD.B       #$30,D6                 * convert data register # to hex digit
0000198C  14C6                     865              MOVE.B      D6,(A2)+                * register # to buffer                  
0000198E                           866              
0000198E  4E75                     867          RTS                                     * Return
00001990                           868   
00001990                           869  EAcode001
00001990  3C07                     870              MOVE.W      D7,D6                   * move current working word into temp storage
00001992  0246 0007                871              ANDI.W      #$7,D6                  * isolate register bits (last 3)
00001996  14FC 0041                872              MOVE.B      #'A',(A2)+              * add "A" to buffer
0000199A  0606 0030                873              ADD.B       #$30,D6                 * convert data register # to hex digit
0000199E  14C6                     874              MOVE.B      D6,(A2)+                * register # to buffer
000019A0                           875                
000019A0  4E75                     876              RTS                                 * Return
000019A2                           877  
000019A2                           878  EAcode010
000019A2  3C07                     879              MOVE.W      D7,D6                   * move current working word into temp storage
000019A4  0246 0007                880              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019A8  14FC 0028                881              MOVE.B      #'(',(A2)+              * add "(" to buffer            
000019AC  14FC 0041                882              MOVE.B      #'A',(A2)+              * add "A" to buffer
000019B0  0606 0030                883              ADD.B       #$30,D6                 * convert data register # to hex digit
000019B4  14C6                     884              MOVE.B      D6,(A2)+                * register # to buffer
000019B6  14FC 0029                885              MOVE.B      #')',(A2)+              * add ")" to buffer
000019BA                           886               
000019BA  4E75                     887              RTS                                 * Return
000019BC                           888   
000019BC                           889  EAcode011
000019BC                           890              
000019BC  3C07                     891              MOVE.W      D7,D6                   * move current working word into temp storage
000019BE  0246 0007                892              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019C2  14FC 0028                893              MOVE.B      #'(',(A2)+              * add "(" to buffer            
000019C6  14FC 0041                894              MOVE.B      #'A',(A2)+              * add "A" to buffer
000019CA  0606 0030                895              ADD.B       #$30,D6                 * convert data register # to hex digit
000019CE  14C6                     896              MOVE.B      D6,(A2)+                * register # to buffer
000019D0  14FC 0029                897              MOVE.B      #')',(A2)+              * add ")" to buffer
000019D4  14FC 002B                898              MOVE.B      #'+',(A2)+              * add "+" to buffer
000019D8  4E75                     899              RTS
000019DA                           900  
000019DA  3C07                     901  EAcode100   MOVE.W      D7,D6                   * move current working word into temp storage
000019DC  0246 0007                902              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019E0  14FC 002D                903              MOVE.B      #'-',(A2)+              * add "-" to buffer
000019E4  14FC 0028                904              MOVE.B      #'(',(A2)+              * add "(" to buffer            
000019E8  14FC 0041                905              MOVE.B      #'A',(A2)+              * add "A" to buffer
000019EC  0606 0030                906              ADD.B       #$30,D6                 * convert data register # to hex digit
000019F0  14C6                     907              MOVE.B      D6,(A2)+                * register # to buffer
000019F2  14FC 0029                908              MOVE.B      #')',(A2)+              * add ")" to buffer
000019F6  4E75                     909              RTS                                     * Return
000019F8                           910              
000019F8                           911  EAcode101
000019F8  4EF8 1890                912               JMP    badInst          * set bad instruction flag
000019FC                           913  EAcode110
000019FC  4EF8 1890                914              JMP       badInst             * set bad instruction flag
00001A00                           915  
00001A00                           916  EAcode111
00001A00  4EB9 00001A24            917              JSR      regBits             * Get Register bits
00001A06  0C06 0000                918              CMPI.B   #$0,D6              * compare to determine if it's a word
00001A0A  6700 0066                919              BEQ      word2Buffer         * put word address in buffer
00001A0E  0C06 0001                920              CMPI.B   #$1,D6              * compare to determine if it's a long
00001A12  6700 0090                921              BEQ      long2Buffer         * put long address in buffer
00001A16  0C06 0002                922              CMPI.B   #$2,D6
00001A1A                           923  
00001A1A  0C06 0002                924              CMPI.B   #$2,D6              * compare to determine if it's PC w/ Displacement
00001A1E  6700 000C                925              BEQ      pctobuffer             
00001A22                           926              ;CMPI.B   #$4,D6              * compare to determine if it's Immediate
00001A22                           927              ;BEQ      imm2Buffer          * DON"T HAVE THIS CASE YET
00001A22                           928             
00001A22  4E75                     929              RTS
00001A24                           930  
00001A24  3C07                     931  regBits     MOVE.W  D7,D6     * change D2 to A0  (simulating address)
00001A26  0246 0007                932              ANDI.W  #$07,D6
00001A2A  4E75                     933              RTS
00001A2C                           934   
00001A2C                           935  ; Add '(pc)' to buffer
00001A2C                           936  pctobuffer
00001A2C  4EB9 00001A72            937              JSR         word2Buffer
00001A32  14FC 0028                938              MOVE.B      #'(',(A2)+                        
00001A36  14FC 0050                939              MOVE.B      #'P',(A2)+              
00001A3A  14FC 0043                940              MOVE.B      #'C',(A2)+              
00001A3E  14FC 0029                941              MOVE.B      #')',(A2)+                                     
00001A42  4E75                     942              RTS
00001A44                           943  
00001A44                           944  byte2Buffer   
00001A44  14FC 0024                945              MOVE.B  #'$',(A2)+
00001A48  4284                     946              CLR.L   D4          * pre-emptive clearout
00001A4A  3410                     947              MOVE.W  (A0),D2       * move current word into D2 for rolling purposes
00001A4C  4284                     948              CLR.L   D4          * pre-emptive clearout
00001A4E  183C 0002                949              MOVE.B  #2,D4       * load a counter
00001A52                           950  
00001A52                           951  b2bLoop                 
00001A52  B83C 0000                952              CMP.B   #$00,D4     * compare counter with 0
00001A56  6700 0014                953              BEQ     rtnEA0      * if zero, return
00001A5A  E91A                     954              ROL.B   #4,D2       * roll the bits in D2 to the left
00001A5C  3C02                     955              MOVE.W  D2,D6       * move rolled bits into temp storage
00001A5E  0246 000F                956              ANDI.W  #$000F,D6   * and the bits to isolate ascii char   
00001A62  4EB8 190C                957              JSR     Hex2ASCII   * load ascii char into buffer            
00001A66  5304                     958              SUBQ.B  #$1,D4      * subtract from counter
00001A68  4EF8 1A52                959              JMP     b2bLoop     * keep looping until counter hits zero
00001A6C                           960              
00001A6C  3C07                     961  rtnEA0      MOVE.W  D7,D6       * re-load current word for temp storage            
00001A6E  5448                     962              ADDQ.W  #2,A0       * advancing memory pointer by word   
00001A70  4E75                     963              RTS                 * return from subroutine
00001A72                           964              
00001A72                           965  word2Buffer 
00001A72  14FC 0024                966              MOVE.B  #'$',(A2)+  
00001A76  4284                     967              CLR.L   D4          * pre-emptive clearout
00001A78  14FC 0024                968              MOVE.B  #$24,(A2)+  * put dollar sign in buffer (before address)
00001A7C  3410                     969              MOVE.W  (A0),D2       * move current word into D2 for rolling purposes
00001A7E  4284                     970              CLR.L   D4          * pre-emptive clearout
00001A80  183C 0004                971              MOVE.B  #4,D4       * load a counter
00001A84                           972  
00001A84                           973  w2bLoop                 
00001A84  B83C 0000                974              CMP.B   #$00,D4     * compare counter with 0
00001A88  6700 0014                975              BEQ     rtnEA1      * if zero, return
00001A8C  E95A                     976              ROL.W   #4,D2       * roll the bits in D2 to the left
00001A8E  3C02                     977              MOVE.W  D2,D6       * move rolled bits into temp storage
00001A90  0246 000F                978              ANDI.W  #$000F,D6   * and the bits to isolate ascii char   
00001A94  4EB8 190C                979              JSR     Hex2ASCII   * load ascii char into buffer            
00001A98  5304                     980              SUBQ.B  #$1,D4      * subtract from counter
00001A9A  4EF8 1A84                981              JMP     w2bLoop     * keep looping until counter hits zero
00001A9E                           982              
00001A9E  3C07                     983  rtnEA1      MOVE.W  D7,D6       * re-load current word for temp storage            
00001AA0  5448                     984              ADDQ.W  #2,A0       * advancing memory pointer by word   
00001AA2  4E75                     985              RTS                 * return from subroutine
00001AA4                           986  
00001AA4                           987  long2Buffer
00001AA4  14FC 0024                988              MOVE.B  #'$',(A2)+
00001AA8  4284                     989              CLR.L   D4          * pre-emptive clearout
00001AAA  2410                     990              MOVE.L  (A0),D2       * move current word into D2 for rolling purposes
00001AAC  4284                     991              CLR.L   D4          * pre-emptive clearout
00001AAE  183C 0008                992              MOVE.B  #8,D4       * load a counter
00001AB2                           993  
00001AB2                           994  l2bLoop                 
00001AB2  B83C 0000                995              CMP.B   #$00,D4     * compare counter with 0
00001AB6  6700 0014                996              BEQ     rtnEA2      * if zero, return
00001ABA  E99A                     997              ROL.L   #4,D2       * roll the bits in D2 to the left
00001ABC  3C02                     998              MOVE.W  D2,D6       * move rolled bits into temp storage
00001ABE  0246 000F                999              ANDI.W  #$000F,D6   * and the bits to isolate ascii char   
00001AC2  4EB8 190C               1000              JSR     Hex2ASCII   * load ascii char into buffer            
00001AC6  5304                    1001              SUBQ.B  #$1,D4      * subtract from counter
00001AC8  4EF8 1AB2               1002              JMP     l2bLoop     * keep looping until counter hits zero
00001ACC                          1003              
00001ACC  3C07                    1004  rtnEA2      MOVE.W  D7,D6       * re-load current word for temp storage
00001ACE  5848                    1005              ADDQ.W  #4,A0       * advancing memory pointer by long
00001AD0  4E75                    1006              RTS                 * return from subroutine
00001AD2                          1007  
00001AD2                          1008  
00001AD2                          1009                     
00004000                          1010               ORG   $4000 ; Make sure data starts at $4000
00004000= 48 65 6C 6C 6F 2C ...   1011  intro        DC.B    'Hello, please enter beginning and ending addresses',CR,LF
00004034                          1012  
00004034= 0034                    1013  intro_len   DC.W    intro_len-intro
00004036                          1014          
00004036= 45 6E 74 65 72 20 ...   1015  string1     DC.B    'Enter start address: $',0
0000404E= 0018                    1016  str_len1    DC.W    str_len1-string1  *Get the length of the string
00004050                          1017  
00004050= 45 6E 74 65 72 20 ...   1018  string2     DC.B    'Enter end address: $',0
00004066= 0016                    1019  str_len2    DC.W    str_len2-string2  *Get the length of the string
00004068                          1020  
00004068= 50 72 65 73 73 20 ...   1021  str_enter   DC.B    'Press enter to read more data',0
00004086= FFE2                    1022  str_en_len  DC.W    str_enter-str_en_len
00004088                          1023  
00004088= 44 69 73 61 73 73 ...   1024  str_more    DC.B    'Disassemble more code? 1 for yes, 0 for no. ',0
000040B6= 002E                    1025  strMore_len DC.W    strMore_len-str_more       
000040B8                          1026  
000040B8= 43 6C 6F 73 69 6E ...   1027  exit        DC.B    'Closing program',0
000040C8= 0010                    1028  exit_len    DC.W    exit_len-exit           
000040CA                          1029  
000040CA= 01                      1030  message_buffer    DC.B   1
000040CB                          1031                                   
000040CB                          1032  *************************************************************************************************************************
000040CB                          1033  * End of program:
000040CB                          1034  *************************************************************************************************************************        
000040CC  4E72 2700               1035  END         STOP    #$2700
000040D0                          1036              END     $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDAL               162C
ASCIITOHEX          10F0
B2BLOOP             1A52
BADINST             1890
BUFFPREP            118A
BYTE2BUFFER         1A44
CAP_TO_HEX          115E
CLEARALL            107A
CLRREGS             18FC
CMDSH1              185A
CMDSH2              1862
CMDSH3              1876
CMDSH4              187C
CMPAL               1548
CR                  D
EACODE000           197E
EACODE001           1990
EACODE010           19A2
EACODE011           19BC
EACODE100           19DA
EACODE101           19F8
EACODE110           19FC
EACODE111           1A00
EA_MODE_TABLE       194E
END                 40CC
END0000             12A6
END0010             130C
END0011             1372
END0100             142A
END1001             1502
END1011             15BE
END1100             15EE
END1101             16AC
ENDBUFF             11CE
ENDINPUT            10EE
ENDUTIL             108C
EXIT                40B8
EXIT_LEN            40C8
FILL_ADDRESS        117C
FINISH              1172
GETADDR             17E2
GETDIRBIT           17D8
GETEA               1924
GETLONG             17FC
GETOP               11EE
GETSIZE             1786
HEX1_0000           124E
HEX1_0001           12A8
HEX1_0011           130E
HEX1_0100           13C8
HEX1_0101           142C
HEX1_0110           1434
HEX1_0111           143E
HEX1_1001           1446
HEX1_1010           1504
HEX1_1011           150C
HEX1_1100           15C0
HEX1_1101           15F0
HEX2ASCII           190C
HEX2_1111           1784
HEX4_0000           16F6
HEX4_0001           16FE
HEX4_0011           1706
HEX4_0101           170E
HEX4_0111           1716
HEX4_1000           171E
HEX4_1001           1738
HEX4_1010           1740
HEX4_1011           1748
HEX4_1100           1750
HEX4_1101           1758
HEX4_1110           1768
HEX4_1111           1760
HIGHREGBITS         17C6
INPUT               108E
INTRO               4000
INTRO_LEN           4034
IN_START            1016
L2BLOOP             1AB2
LETTER              191C
LF                  A
LOADDATABUFFER      18B6
LONG2BUFFER         1AA4
LOOP2               1102
LOWER_TO_HEX        1168
MAINB               17B6
MAINEND             17C4
MAINW               17C0
MESSAGE_BUFFER      40CA
MOVEL               12E2
MOVELEA             12F6
MOVEPTR             15E6
MOVESIZE            1396
MOVESIZEL           13C2
MOVESIZEW           13B8
MOVEW               1348
MOVEWEA             135C
MSIZEEND            13C6
MULUMODE            15D0
NUM_TO_HEX          1154
OPADD               1656
OPADD01             1698
OPADDA              1630
OPCMP               157E
OPCMPA              154C
OPCMPEOR            1572
OPDECODE            11D0
OPLEA               13F6
OPMOVEM             1730
OPMULU              15C2
OPORI               1266
OPRETURN            11E8
OPSUB               14AC
OPSUB01             14EE
OPSUBA              1486
PCTOBUFFER          1A2C
PRINTCOUNT          14
PRINT_EXIT          1066
REGBITS             1A24
RESUME              113C
RTNEA0              1A6C
RTNEA1              1A9E
RTNEA2              1ACC
SHIFT12BITS         C
SHIFT4BITS          4
SHIFT8BITS          8
SHOW                1052
SIZE2BUFFER         1790
STACK               A000
START               1000
STRING1             4036
STRING2             4050
STRMORE_LEN         40B6
STR_ENTER           4068
STR_EN_LEN          4086
STR_LEN1            404E
STR_LEN2            4066
STR_MORE            4088
SUBAL               1482
SWAPDESTREG         1374
TBL_0100            16AE
TBL_OP              1206
W2BLOOP             1A84
WORD2BUFFER         1A72
WRITE2BUFF          1920
