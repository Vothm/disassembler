00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/15/2021 11:18:07 AM

00000000                             1  *-----------------------------------------------------------------
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Vince Maranan
00000000                             4  * Description: CSS422 Final Project
00000000                             5  *-----------------------------------------------------------------
00000000                             6  
00000000                             7  ; Variables
00000000                             8              OPT     CRE 
00000000  =0000A000                  9  stack       EQU     $A000               * Stack Address
00000000  =00000000                 10  badFlag     EQU     0                   * Bad flag
00000000  =00000001                 11  goodFlag    EQU     1                   * Good flag
00000000  =00000004                 12  shift4bits  EQU     4                   * Shift 4 bits
00000000  =00000008                 13  shift8bits  EQU     8                   * Shift 8 bits 
00000000  =0000000C                 14  shift12bits EQU     12                  * Shift 12 bits
00000000  =00000000                 15  task0       EQU     00                  * output command
00000000  =00000001                 16  task1       EQU     01                  * output command
00000000  =00000002                 17  task2       EQU     02                  * output command
00000000  =0000000D                 18  task13      EQU     13                  * output command
00000000  =00000014                 19  printCount  EQU     20                  * Amount of lines to display to console at once
00000000  =0000000D                 20  CR          EQU     $0D                 
00000000  =0000000A                 21  LF          EQU     $0A                 
00000000                            22  
00000000                            23  
00001000                            24              ORG     $1000
00001000                            25              
00001000  6100 0050                 26  start:      BSR     print_intro         * Intro
00001004  6100 0074                 27              BSR     CLEARALL             
00001008  4FF9 0000A000             28              LEA     stack,SP            * Load stack pointer       
0000100E  45F9 00004168             29              LEA     message_buffer,A2         * buffer resides in A2
00001014  2C4A                      30              MOVEA.L A2,A6               * reference to start of good buffer
00001016                            31      
00001016  6100 0076                 32  in_start    BSR     INPUT
0000101A                            33              ;BSR     CHECK_ADD            
0000101A                            34              ;CMP     #badFlag,D5
0000101A                            35              ;BEQ     in_start 
0000101A  6100 0178                 36              BSR     buffPrep
0000101E  103C 0001                 37              MOVE.B  #task1,D0
00001022  43F9 00004126             38              LEA     str_more,A1
00001028  3239 00004154             39              MOVE.W  strMore_len,D1
0000102E  4E4F                      40              TRAP    #15
00001030  103C 0002                 41              MOVE.B  #task2,D0
00001034  4E4F                      42              TRAP    #15
00001036  1611                      43              MOVE.B  (A1),D3     * copy input to D3
00001038  12FC 0057                 44              MOVE.B  #$57,(A1)+  * write in 'W'
0000103C  12BC 006F                 45              MOVE.B  #$6F,(A1)   * write in 'u'
00001040  B63C 0031                 46              CMP.B   #$31,D3     * compare ASCII 1 to D3
00001044  67BA                      47              BEQ     start
00001046  67B8                      48              BEQ     start
00001048  6100 001C                 49              BSR     print_exit
0000104C  4EF9 0000416A             50              JMP     end
00001052                            51          
00001052                            52  
00001052                            53  ****************************************************************************************************************
00001052                            54  * Purpose: looks at the address entered by the user by checking the following:
00001052                            55  *1. checks if addresses are odd*  if yes, subtracts 1 bit to make it even.
00001052                            56  *2. checks if starting address < $00FFFFFF*  if no, display error and prompt user for inputs
00001052                            57  *3. checks if ending address <= $00FFFFFF*  if no, display error and prompt user for inputs
00001052                            58  *4. checks if ending address > starting address*  if no, display error and prompt user for inputs
00001052                            59  *5. when all conditions pass, subroutine returns to main  
00001052                            60  * parameters:
00001052                            61  *-A0: starting address
00001052                            62  *-A4: ending address
00001052                            63  *-D2: copy of address
00001052                            64  *-D3: utility register
00001052                            65  ****************************************************************************************************************
00001052                            66  
00001052                            67  ;Utility functions (Printing, clearning, checking addresses)
00001052                            68  
00001052  103C 000D                 69  print_intro MOVE.B  #13,D0
00001056  43F9 00004000             70              LEA     intro,A1
0000105C  3239 00004034             71              MOVE.W  intro_len,D1
00001062  4E4F                      72              TRAP    #15
00001064  4E75                      73              RTS
00001066                            74  
00001066  103C 0001                 75  print_exit  MOVE.B  #task1,D0
0000106A  43F9 00004156             76              LEA     exit,A1
00001070  3239 00004166             77              MOVE.W  exit_len,D1
00001076  4E4F                      78              TRAP    #15
00001078  4E75                      79              RTS        
0000107A                            80  
0000107A  4240                      81  CLEARALL    CLR     D0
0000107C  4241                      82              CLR     D1
0000107E  4242                      83              CLR     D2
00001080  4243                      84              CLR     D3
00001082  4244                      85              CLR     D4
00001084  4245                      86              CLR     D5
00001086  4246                      87              CLR     D6
00001088  4247                      88              CLR     D7
0000108A  4E75                      89              RTS
0000108C                            90                 
0000108C                            91                          
0000108C  4E75                      92  ca_End      RTS
0000108E                            93  INPUT:
0000108E  103C 0001                 94              MOVE.B  #task1,D0
00001092  43F9 00004036             95              LEA     string1,A1
00001098  3239 00004050             96              MOVE.W  str_len1,D1         
0000109E  4E4F                      97              TRAP    #15
000010A0  D3FC 00004050             98              ADDA.L  #str_len1,A1         * add input immediately after string
000010A6  103C 0002                 99              MOVE.B  #task2,D0      
000010AA  4E4F                     100              TRAP    #15
000010AC  4EB9 000010F0            101              JSR     asciiTOhex            * conv an A!! check for bad / good flag after checking user's address
000010B2  BA3C 0000                102              CMP.B   #$00,D5
000010B6  6700 0036                103              BEQ     endInput
000010BA                           104              
000010BA  2848                     105              MOVEA.L A0,A4         
000010BC  103C 0001                106              MOVE.B  #task1,D0
000010C0  43F9 00004052            107              LEA     string2,A1
000010C6  3239 0000406A            108              MOVE.W  str_len2,D1         
000010CC  4E4F                     109              TRAP    #15         
000010CE  D3FC 0000406A            110              ADDA.L  #str_len2,A1
000010D4  103C 0002                111              MOVE.B  #task2,D0
000010D8  4E4F                     112              TRAP    #15
000010DA  4EB9 000010F0            113              JSR     asciiTOhex
000010E0  BA3C 0000                114              CMP.B   #$00,D5
000010E4  6700 0008                115              BEQ          endInput
000010E8                           116              
000010E8                           117             
000010E8                           118             **********swap************
000010E8  264C                     119              MOVEA.L A4,A3               *store starting into register
000010EA  2848                     120              MOVEA.L A0,A4               *copy ending to A4
000010EC  204B                     121              MOVEA.L A3,A0               *store starting in A0                    
000010EE  4E75                     122  endInput    RTS
000010F0                           123  
000010F0                           124  *********************************************************************************************************************
000010F0                           125  * Ascii To Hex
000010F0                           126  * 
000010F0                           127  *   Register Usage:
000010F0                           128  *       D3 - Placeholder for current ascii byte (based off of User's Inputted Address)   
000010F0                           129  *     D4 - Translated Address
000010F0                           130  *           A0 - At the end of the routine, store the converted address here
000010F0                           131  * 
000010F0                           132  *   TODO:          
000010F0                           133  *       - Replace clear commands with a an official subroutine call (not critical)
000010F0                           134  *       - Test for the length of the address given (critical)
000010F0                           135  *
000010F0                           136  *
000010F0                           137  *
000010F0                           138  ****************************************************************************************************************
000010F0                           139  
000010F0                           140  asciiTOhex
000010F0                           141  
000010F0  48E7 F800                142              MOVEM.L D0-D4,-(SP)         * save data registers to the stack
000010F4  1A3C 0001                143              MOVE.B  #goodFlag,D5        * set flag to good (until proven otherwise)
000010F8  4EB9 00001906            144              JSR     clrRegs
000010FE  3C3C 0000                145              MOVE    #0,D6      
00001102                           146        
00001102  1619                     147  loop2       MOVE.B  (A1)+,D3            * store current ascii byte into D3 (user's input)
00001104  B63C 0030                148              CMP.B   #$30,D3             * is ascii byte < 30??  if so, throw ascii exception
00001108  6D00 0068                149              BLT     asciiError
0000110C  B63C 003A                150              CMP.B   #$3A,D3             * is ascii byte < 3A??  if so, convert to number
00001110  6D00 0042                151              BLT     num_to_hex      
00001114  B63C 0041                152              CMP.B   #$41,D3             * is ascii byte < 41??  if so, error
00001118  6D00 0058                153              BLT     asciiError
0000111C  B63C 0047                154              CMP.B   #$47,D3             * is ascii byte < 47?   if so, convert to capital letter
00001120  6D00 003C                155              BLT     cap_to_hex
00001124  B63C 0061                156              CMP.B   #$61,D3             * is ascii byte < 61?   if so, error
00001128  6D00 0048                157              BLT     asciiError
0000112C  B63C 0067                158              CMP.B   #$67,D3             * is ascii byte < 67?   if so, convert to lowercase letter
00001130  6D00 0036                159              BLT     lower_to_hex
00001134  B63C 0066                160              CMP.B   #$66,D3             * is ascii byte > 66?   if so, error
00001138  6E00 0038                161              BGT     asciiError  
0000113C                           162        
0000113C                           163  resume    
0000113C  5246                     164              ADD     #1,D6               * increment length counter
0000113E  BC7C 0006                165              CMP     #6,D6               * compare to 6
00001142  6700 0038                166              BEQ     return              * if length is 6 digits long, jump to return              
00001146  0C11 0000                167              CMP.B   #$00,(A1)           * null terminator? if so, we are done
0000114A  6700 0030                168              BEQ     return              * move to clean-up duties
0000114E  E984                     169              ASL.L   #4,D4               * shift D4 left by 4 bits in order to make room for next value            
00001150  4EF8 1102                170              JMP     loop2               * perform clean-up duties & exit subroutine
00001154                           171  
00001154                           172  num_to_hex
00001154  0403 0030                173              SUBI.B  #$30,D3             * subtracting hex values leaves us with appropriate single-digit hex value
00001158  D803                     174              ADD.B   D3,D4               * add latest hex value to temporary storage
0000115A  4EF8 113C                175              JMP     resume              * resume regularly sheduled programming
0000115E                           176  
0000115E                           177  cap_to_hex
0000115E                           178  
0000115E  0403 0037                179              SUBI.B  #$37,D3             * subtracting hex values leaves us with appropriate capital letter hex value
00001162  D803                     180              ADD.B   D3,D4               * add latest hex value to temporary storag
00001164  4EF8 113C                181              JMP     resume              * resume regularly sheduled programming
00001168                           182  
00001168                           183  lower_to_hex
00001168  0403 0057                184              SUBI.B  #$57,D3             * subtracting hex values leaves us with appropriate lowercase letter hex value
0000116C  D803                     185              ADD.B   D3,D4               * add latest hex value to temporary storag
0000116E  4EF8 113C                186              JMP     resume              * resume regularly sheduled programming
00001172                           187  
00001172  1A3C 0000                188  asciiError  MOVE.B  #00,D5              * set bad flag      
00001176  4EF9 0000117C            189              JMP     return              * perform clean-up duties & exit subroutine
0000117C                           190  
0000117C  2044                     191  return      MOVE.L  D4,A0
0000117E  4246                     192              CLR     D6                  * clear counter
00001180  4CDF 001F                193              MOVEM.L (SP)+,D0-D4         * load data registers from stack      
00001184  4E75                     194              RTS                         * return from subroutine
00001186                           195          
00001186                           196              
00001186                           197  ***************************** End of asciiTOhex routine **************************************************************
00001186                           198  
00001186                           199         
00001186                           200  
00001186                           201  
00001186                           202  
00001186                           203  **********************************************************************************************************************
00001186                           204  * Fills the buffer with the current address
00001186                           205  * Parameters:
00001186                           206  * A1: Trap Address
00001186                           207  * A2: Pointer of buffer
00001186  224A                     208  FILL_ADDRESS: MOVEA.L  A2,A1              *load trap address with A2                     JSR      getLongtLong
00001188  4EB9 00001806            209                JSR getLong
0000118E  14FC 0009                210                MOVE.B   #$09,(A2)+                                   
00001192  4E75                     211               RTS
00001194                           212            
00001194                           213              
00001194                           214  
00001194                           215  * prepares buffer for filling in current address, OpCode, and EA
00001194                           216  * Parameters:
00001194                           217  * A0: Current address
00001194                           218  * A1: Trap Address
00001194                           219  * A2: Buffer Pointer
00001194                           220  * A4: Ending Address
00001194                           221  * D0: task number
00001194                           222  * D1: length of str_enter
00001194                           223  * D7: counter for number of lines printed
00001194                           224  **********************************************************************************************************************   
00001194  244E                     225  buffPrep    MOVEA.L A6,A2         
00001196  61EE                     226              BSR     FILL_ADDRESS        * fill buffer with current address
00001198  4EB9 000011DA            227              JSR     opDecode
0000119E  14BC 0000                228              MOVE.B  #00,(A2)            * null terminater
000011A2  103C 000D                229              MOVE.B  #task13,D0
000011A6  4E4F                     230              TRAP    #15                 * print decoded Op
000011A8                           231                                
000011A8  B9C8                     232              CMPA.L   A0,A4              * have we reached the end of our address range?
000011AA  6F00 002C                233              BLE      endBuff
000011AE                           234              
000011AE  5247                     235              ADDI    #1,D7               * increment counter
000011B0  BE7C 0014                236              CMP     #printCount,D7
000011B4  66DE                     237              BNE     buffPrep
000011B6                           238              
000011B6  103C 0001                239              MOVE.B  #task1,D0
000011BA  43F9 00004106            240              LEA     str_enter,A1
000011C0  3239 00004124            241              MOVE.W  str_en_len,D1
000011C6  4E4F                     242              TRAP    #15
000011C8                           243              
000011C8  103C 0002                244              MOVE.B  #task2,D0
000011CC  4E4F                     245              TRAP    #15
000011CE                           246              
000011CE  12BC 0050                247              MOVE.B  #$50,(A1)
000011D2                           248              
000011D2  4247                     249              CLR     D7                  *reset counter
000011D4  4EF8 1194                250              JMP     buffPrep
000011D8                           251              
000011D8  4E75                     252  endBuff     RTS         
000011DA                           253            
000011DA                           254  ********************************************************************************************************************** 
000011DA                           255  * Start of opDecode section - setup process for decoding instruction
000011DA                           256  * Registers used: 
000011DA                           257  *   A0/A5 = Memory pointer
000011DA                           258  *   A2 = Good buffer pointer
000011DA                           259  *   A5 = Index for jump tables      (Dynamically used)
000011DA                           260  *   A6 = Holds previous buffer spot (Dynamically used)
000011DA                           261  *   D2 = Size returned from getSize function(s)      (Dynamically used)
000011DA                           262  *   D4 = Size of Shift              (Dynamically used)
000011DA                           263  *   D5 = Pass/Fail Flag
000011DA                           264  *   D6 = Copy of D7 to shift        (Dynamically used)
000011DA                           265  *   D7 = Current Word Value
000011DA                           266  *   (A1, D0, D1 = Trap Commands) 
000011DA                           267  *   (A7 = SP)
000011DA                           268  ********************************************************************************************************************** 
000011DA  48E7 FB0E                269  opDecode    MOVEM.L A4-A6/D0-D4/D6-D7,-(SP)      * Save registers
000011DE  4EB9 00001906            270              JSR     clrRegs             * Clear registers for use
000011E4  1A3C 0001                271              MOVE.B  #goodFlag,D5        * Set good flag until fail
000011E8  3E18                     272              MOVE.W  (A0)+,D7            * Move instruction to D7 & Increment pointer
000011EA  264A                     273              MOVEA.L A2,A3               * Store buffer location                 
000011EC  4EB9 000011F8            274              JSR     getOp               * Decode instruction Test
000011F2                           275  
000011F2                           276  
000011F2                           277  
000011F2                           278  ********************************************************************************************************************** 
000011F2                           279  * Start of opReturn section - clean up process and return to IO
000011F2                           280  ********************************************************************************************************************** 
000011F2  4CDF 70DF                281  opReturn    MOVEM.L (SP)+,D6-D7/D0-D4/A4-A6   * Clean up, restore registers
000011F6  4E75                     282              RTS              * replace with IO Call
000011F8                           283              
000011F8                           284              
000011F8                           285              
000011F8                           286              
000011F8                           287  ********************************************************************************************************************** 
000011F8                           288  * Start of getOp section - decode 1st 4 bits
000011F8                           289  **********************************************************************************************************************                              
000011F8  3C07                     290  getOp       MOVE.W  D7,D6               * Move instruction to shift
000011FA  183C 000C                291              MOVE.B  #shift12bits,D4         * Load shifter register
000011FE  E86E                     292              LSR.W   D4,D6               * Shift right 12 bits
00001200  CCFC 0006                293              MULU    #6,D6               * Form offset           
00001204  4BF9 00001210            294              LEA     tbl_op,A5           * Index into the table                                                                                   
0000120A  4EB5 6000                295              JSR     00(A5,D6)           * Jump indirect with index (00 indicates word movement)
0000120E  4E75                     296              RTS
00001210                           297  
00001210                           298  
00001210                           299  
00001210                           300  ********************************************************************************************************************** 
00001210                           301  * Beginning of the main table: tbl_op
00001210                           302  * Contains the functions per the first 4 bits of current instruction.
00001210                           303  ********************************************************************************************************************** 
00001210                           304  tbl_op      
00001210  4EF9 00001258            305              JMP     hex1_0000            
00001216  4EF9 000012B2            306              JMP     hex1_0001            
0000121C                           307              ;JMP     hex1_0010
0000121C  4EF9 00001318            308              JMP     hex1_0011
00001222  4EF9 000013D2            309              JMP     hex1_0100
00001228  4EF9 00001436            310              JMP     hex1_0101
0000122E  4EF9 0000143E            311              JMP     hex1_0110
00001234  4EF9 00001448            312              JMP     hex1_0111
0000123A                           313              ;JMP     hex1_1000
0000123A  4EF9 00001450            314              JMP     hex1_1001
00001240  4EF9 0000150E            315              JMP     hex1_1010
00001246  4EF9 00001516            316              JMP     hex1_1011
0000124C  4EF9 000015CA            317              JMP     hex1_1100
00001252  4EF9 000015FA            318              JMP     hex1_1101
00001258                           319              ;JMP     hex1_1110
00001258                           320              ;JMP     hex1_1111
00001258                           321  
00001258                           322  ********************************************************************************************************************** 
00001258                           323  * Case for: first four bits = 0000
00001258                           324  * --(ORI) 
00001258                           325  ********************************************************************************************************************** 
00001258  3C07                     326  hex1_0000   MOVE.W  D7,D6               * Fresh copy of instruction to shift
0000125A  0246 0F00                327              ANDI.W  #$0F00,D6           * Isolate second byte
0000125E  183C 0008                328              MOVE.B  #shift8bits,D4          * Load shifter
00001262  E8AE                     329              LSR.L   D4,D6               * Shift to LSB
00001264  BC3C 0000                330              CMP.B   #$0,D6              * Is this ORI?
00001268  6700 0006                331              BEQ     opORI               * Jump to opORI section
0000126C  6600 062C                332              BNE     badInst             * No - bad instruction                  
00001270                           333  
00001270  14FC 004F                334  opORI       MOVE.B  #'O',(A2)+          * Populate ORI into buffer
00001274  14FC 0052                335              MOVE.B  #'R',(A2)+
00001278  14FC 0049                336              MOVE.B  #'I',(A2)+
0000127C  14FC 002E                337              MOVE.B  #'.',(A2)+
00001280  4EB9 0000179A            338              JSR     size2Buffer         * determine & add size to buffer
00001286  14FC 0020                339              MOVE.B  #' ',(A2)+
0000128A  14FC 0020                340              MOVE.B  #' ',(A2)+
0000128E  14FC 0020                341              MOVE.B  #' ',(A2)+
00001292  14FC 0020                342              MOVE.B  #' ',(A2)+            
00001296  14FC 0023                343              MOVE.B  #'#',(A2)+            
0000129A  4EB9 000017EC            344              JSR     getAddr             * Add immediate source
000012A0  14FC 002C                345              MOVE.B  #',',(A2)+          * Add comma
000012A4  4EB9 0000192E            346              JSR     getEA               * Print off desitination operand
000012AA  4EF9 000012B0            347              JMP     end0000             * Skip to end of sub: hex1_0000
000012B0                           348  
000012B0  4E75                     349  end0000     RTS
000012B2                           350  ********************************************************************************************************************** 
000012B2                           351  * Case for: first four bits = 0011                                   
000012B2                           352  * MOVE.B
000012B2                           353  ********************************************************************************************************************** 
000012B2                           354  
000012B2                           355  *hex1_0011  MOVE.B  #'M',(A2)+          * Start of MOVE.B OpCode
000012B2                           356  *            MOVE.B  #'O',(A2)+
000012B2                           357  *            MOVE.B  #'V',(A2)+
000012B2                           358  *            MOVE.B  #'E',(A2)+
000012B2                           359  *            MOVE.B  #'.',(A2)+
000012B2                           360  *            MOVE.B  #'B',(A2)+
000012B2                           361  *            MOVE.B  #' ',(A2)+
000012B2                           362  *            MOVE.B  #' ',(A2)+
000012B2                           363  *            MOVE.B  #' ',(A2)+  
000012B2                           364  *            JSR     getEA               * get source destination
000012B2                           365  *            MOVE.B  #',',(A2)+
000012B2                           366  *            JSR     swap4Move           * swap destination and source regs for getEA
000012B2                           367  *            JSR     getEA     
000012B2                           368  *end0001     RTS 
000012B2                           369  *            
000012B2                           370              
000012B2                           371              
000012B2                           372              
000012B2                           373  ********************************************************************************************************************** 
000012B2                           374  * Case for: first four bits = 0001                                 
000012B2                           375  * MOVE.L, MOVEA.L
000012B2                           376  ********************************************************************************************************************** 
000012B2  14FC 004D                377  hex1_0001  MOVE.B  #'M',(A2)+          * Start of MOVE/A.L OpCodes
000012B6  14FC 004F                378              MOVE.B  #'O',(A2)+
000012BA  14FC 0056                379              MOVE.B  #'V',(A2)+
000012BE  14FC 0045                380              MOVE.B  #'E',(A2)+
000012C2  1C07                     381              MOVE.B  D7,D6               * copy fresh instruction to Shift
000012C4  EC8E                     382              LSR.L   #6,D6               * shift by 6 to isolate bits 6-8 in LSB
000012C6  0246 0007                383              ANDI.W  #$07,D6             * determine if MoveA?
000012CA  BC3C 0001                384              CMP.B   #$1,D6              * is this a MOVEA Function?
000012CE  6600 001C                385              BNE     moveL               * no then move to . portion
000012D2  14FC 0041                386              MOVE.B  #'A',(A2)+
000012D6  14FC 002E                387              MOVE.B  #'.',(A2)+
000012DA  14FC 004C                388              MOVE.B  #'L',(A2)+
000012DE  14FC 0020                389              MOVE.B  #' ',(A2)+
000012E2  14FC 0020                390              MOVE.B  #' ',(A2)+
000012E6  4EF9 00001300            391              JMP     moveLEA             * skip to filling out source destination
000012EC  14FC 002E                392  moveL       MOVE.B  #'.',(A2)+
000012F0  14FC 004C                393              MOVE.B  #'L',(A2)+
000012F4  14FC 0020                394              MOVE.B  #' ',(A2)+
000012F8  14FC 0020                395              MOVE.B  #' ',(A2)+
000012FC  14FC 0020                396              MOVE.B  #' ',(A2)+  
00001300  4EB9 0000192E            397  moveLEA     JSR     getEA               * get source destination
00001306  14FC 002C                398              MOVE.B  #',',(A2)+
0000130A  4EB9 0000137E            399              JSR     swap4Move           * swap destination and source regs for getEA
00001310  4EB9 0000192E            400              JSR     getEA     
00001316  4E75                     401  end0010     RTS
00001318                           402   
00001318                           403   
00001318                           404   
00001318                           405  ********************************************************************************************************************** 
00001318                           406  * Case for: first four bits = 0011                                    
00001318                           407  * MOVE.W, MOVEA.W
00001318                           408  ********************************************************************************************************************** 
00001318  14FC 004D                409  hex1_0011   MOVE.B  #'M',(A2)+          * Start of MOVE/A.W OpCodes
0000131C  14FC 004F                410              MOVE.B  #'O',(A2)+
00001320  14FC 0056                411              MOVE.B  #'V',(A2)+
00001324  14FC 0045                412              MOVE.B  #'E',(A2)+
00001328  1C07                     413              MOVE.B  D7,D6               * copy fresh instruction to Shift
0000132A  EC8E                     414              LSR.L   #6,D6               * shift by 6 to isolate bits 6-8 in LSB
0000132C  0246 0007                415              ANDI.W  #$07,D6             * determin if move A?
00001330  BC3C 0001                416              CMP.B   #$1,D6              * is this a MOVEA Function?
00001334  6600 001C                417              BNE     moveW               * no then move to . portion
00001338  14FC 0041                418              MOVE.B  #'A',(A2)+          * yes - populate A
0000133C  14FC 002E                419              MOVE.B  #'.',(A2)+
00001340  14FC 0057                420              MOVE.B  #'W',(A2)+
00001344  14FC 0020                421              MOVE.B  #' ',(A2)+
00001348  14FC 0020                422              MOVE.B  #' ',(A2)+
0000134C  4EF9 00001366            423              JMP     moveWEA             * skip to filling out source destination
00001352  14FC 002E                424  moveW       MOVE.B  #'.',(A2)+
00001356  14FC 0057                425              MOVE.B  #'W',(A2)+
0000135A  14FC 0020                426              MOVE.B  #' ',(A2)+
0000135E  14FC 0020                427              MOVE.B  #' ',(A2)+
00001362  14FC 0020                428              MOVE.B  #' ',(A2)+  
00001366  4EB9 0000192E            429  moveWEA     JSR     getEA               * get source destination
0000136C  14FC 002C                430              MOVE.B  #',',(A2)+
00001370  4EB9 0000137E            431              JSR     swap4Move           * swap destination and source regs for getEA
00001376  4EB9 0000192E            432              JSR     getEA     
0000137C  4E75                     433  end0011     RTS 
0000137E                           434  
0000137E                           435  
0000137E                           436  
0000137E  4283                     437  swap4Move   CLR.L   D3                  * Clear (0000) D3 to hold swap value
00001380  3C07                     438              MOVE.W  D7,D6               * Copy to initial shift get reg bits 9-11
00001382  E04E                     439              LSR.W   #shift8bits,D6          * shift by 8 (9 total)
00001384  E24E                     440              LSR.W   #1,D6               * shift by 1 (9 total)
00001386  0246 0007                441              ANDI.W  #$0007,D6           * Mask/Isolate last 3 bits
0000138A  8646                     442              OR.W    D6,D3               * Place Reg Bits Into D3 for swap
0000138C  3C07                     443              MOVE.W  D7,D6               * Copy to get mode bits 6-8
0000138E  E64E                     444              LSR.W   #3,D6               * shift bits 6-8 down 3 to normal ea position 3-5
00001390  0246 0038                445              ANDI.W  #$0038,D6           * mask bits 3-5
00001394  8646                     446              OR.W    D6,D3               * add the move bits into D3
00001396  4EB9 000013A0            447              JSR     moveSize            * add the move size bits (6-7) into D3 for ea
0000139C  3E03                     448              MOVE.W  D3,D7               * swap register mode to determine destination from ea functions
0000139E  4E75                     449              RTS
000013A0                           450              
000013A0                           451              
000013A0  3C07                     452  moveSize    MOVE.W  D7,D6               * get fresh copy to determine MOVE size
000013A2  E04E                     453              LSR.W   #shift8bits,D6          * shift move size bits 12-13 to LSB
000013A4  E84E                     454              LSR.W   #shift4bits,D6          
000013A6  0246 0003                455              ANDI.W  #$0003,D6           * Isolate move bits
000013AA  BC3C 0001                456              CMP.B   #$1,D6              * is this a byte?
000013AE  6700 0020                457              BEQ     mSizeEnd            * yes - byte size already in bits 6-7 of D3
000013B2  BC3C 0002                458              CMP.B   #$2,D6              * is this a L?
000013B6  6700 0014                459              BEQ     moveSizeL           * yes - Or L size to D3 bits 6-7
000013BA  BC3C 0003                460              CMP.B   #$3,D6              * is this a W?
000013BE  6600 04DA                461              BNE     badInst             * No- then badInst        
000013C2  0043 0040                462  moveSizeW   ORI.W   #$0040,D3           * add size 01 in bits 6-7 (4) into D3
000013C6  4EF9 000013D0            463              JMP     mSizeEnd            * skip to end once done
000013CC  0043 0080                464  moveSizeL   ORI.W   #$0080,D3           * add size 10 in bits 6-7 (4) into D3
000013D0  4E75                     465  mSizeEnd    RTS 
000013D2                           466  
000013D2                           467  
000013D2                           468  
000013D2                           469  ********************************************************************************************************************** 
000013D2                           470  * Case for: first four bits = 0100
000013D2                           471  * --(MOVEM,LEA,NOP)
000013D2                           472  ********************************************************************************************************************** 
000013D2  3C07                     473  hex1_0100   MOVE.W  D7,D6               * Fresh copy of instruction to shift
000013D4  0246 0100                474              ANDI.W  #$0100,D6           * Test isolate 8th bit for LEA
000013D8  BC7C 0100                475              CMP.W   #$0100,D6           * Test if LEA
000013DC  6700 0022                476              BEQ     opLEA               * Yes finish testing for LEA
000013E0  3C07                     477              MOVE.W  D7,D6               * Copy fresh copy of instruction to shift
000013E2  183C 0008                478              MOVE.B  #shift8bits,D4          * Load 8 bit shifter
000013E6  E86E                     479              LSR.W   D4,D6               * Shift current instruction
000013E8  0246 000F                480              ANDI.W  #$000F,D6           * Isolate last 4 bits (LSB)
000013EC  CCFC 0006                481              MULU    #6,D6               * Form offset for next JMP table
000013F0  4BF9 000016B8            482              LEA     tbl_0100,A5         * Load next JMP table 
000013F6  4EB5 6000                483              JSR     00(A5,D6)           * Jump to next instruction per next 4 bits
000013FA  4EF9 00001434            484              JMP     end0100             * Once returned from jump table, skip to end
00001400                           485              
00001400  14FC 004C                486  opLEA       MOVE.B  #'L',(A2)+          * Start input of LEA
00001404  14FC 0045                487              MOVE.B  #'E',(A2)+
00001408  14FC 0041                488              MOVE.B  #'A',(A2)+
0000140C  14FC 0020                489              MOVE.B  #' ',(A2)+
00001410  14FC 0009                490              MOVE.B  #$09,(A2)+ 
00001414  4EB9 0000192E            491              JSR     getEA               * Determine address to go to buffer
0000141A  14FC 002C                492              MOVE.B  #',',(A2)+          * Add comma
0000141E  14FC 0041                493              MOVE.B  #'A',(A2)+          * Add A(x)
00001422  3C07                     494              MOVE.W  D7,D6               * Copy fresh copy of instruction to shift
00001424  183C 0009                495              MOVE.B  #9,D4               * Load 9 bit shifter
00001428  E86E                     496              LSR.W   D4,D6               * Shift current instruction
0000142A  0246 000F                497              ANDI.W  #$000F,D6           * Isolate last 4 bits (LSB)
0000142E  0606 0030                498              ADD.B   #$30,D6             * convert data register # to hex digit
00001432  14C6                     499              MOVE.B  D6,(A2)+            * register # to buffer
00001434  4E75                     500  end0100     RTS
00001436                           501  
00001436  4EB9 0000189A            502  hex1_0101   JSR     badInst             * Invalid Instruction
0000143C  4E75                     503              RTS
0000143E                           504              
0000143E                           505              ***** MOVEM Command
0000143E  4EB9 0000189A            506  hex1_0110   JSR     badInst
00001444  5448                     507              ADDQ.W  #2,A0
00001446  4E75                     508              RTS
00001448                           509  
00001448  4EB9 0000189A            510  hex1_0111   JSR     badInst             * Invalid Instruction
0000144E  4E75                     511              RTS
00001450                           512             
00001450                           513  
00001450                           514  
00001450                           515  ********************************************************************************************************************** 
00001450                           516  * Case for: first four bits = 1001
00001450                           517  * --(SUB,SUBA) - Need to look into possibilites with immediate
00001450                           518  ********************************************************************************************************************** 
00001450  14FC 0053                519  hex1_1001   MOVE.B  #'S',(A2)+          * Put ADD into Buff
00001454  14FC 0055                520              MOVE.B  #'U',(A2)+
00001458  14FC 0042                521              MOVE.B  #'B',(A2)+
0000145C  4EB9 00001790            522              JSR     getSize             * return size  in 6 & 7 into D6
00001462  BC3C 0003                523              CMP.B   #%11,D6             * determine if a ADD or ADDA
00001466  6600 004E                524              BNE     opSUB               * not size 11, then skip to ADD
0000146A  14FC 0041                525              MOVE.B  #'A',(A2)+          * yep, detected 11 then ADDA
0000146E  14FC 002E                526              MOVE.B  #'.',(A2)+
00001472  3C07                     527              MOVE.W  D7,D6               * fresh copy of instruction
00001474  E08E                     528              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
00001476  0246 0001                529              ANDI.W  #$0001,D6           * Isolate last bit for size
0000147A  BC3C 0001                530              CMP.B   #%1,D6              * compare for a 1 to determine
0000147E  6700 000C                531              BEQ     subaL               * jump to long, else word
00001482  14FC 0057                532              MOVE.B  #'W',(A2)+          * add word size into buffer
00001486  4EF9 00001490            533              JMP     opSUBA
0000148C  14FC 004C                534  subaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
00001490  14FC 0020                535  opSUBA      MOVE.B  #' ',(A2)+
00001494  14FC 0020                536              MOVE.B  #' ',(A2)+
00001498  14FC 0020                537              MOVE.B  #' ',(A2)+
0000149C                           538              **** NOTE NEED TO TEST FOR EA to ADD $
0000149C  4EB9 0000192E            539              JSR     getEA               * get source operand
000014A2  14FC 002C                540              MOVE.B  #',',(A2)+
000014A6  14FC 0041                541              MOVE.B  #'A',(A2)+  
000014AA  4EB9 000017D0            542              JSR     highRegBits         * Add register number to buffer
000014B0  4EF9 000016B6            543              JMP     end1101
000014B6                           544              
000014B6  14FC 002E                545  opSUB       MOVE.B  #'.',(A2)+          * finish putting Add.x to buffer
000014BA  4EB9 0000179A            546              JSR     size2Buffer         * Determine Size and Add to Buffer
000014C0  14FC 0020                547              MOVE.B  #' ',(A2)+
000014C4  14FC 0020                548              MOVE.B  #' ',(A2)+
000014C8  14FC 0020                549              MOVE.B  #' ',(A2)+
000014CC  14FC 0020                550              MOVE.B  #' ',(A2)+
000014D0  4EB9 000017E2            551              JSR     getDirBit           * get Direction Bit 0 = EA 1 =regs
000014D6  BC3C 0000                552              CMP.B   #%0,D6              * is this EA first?
000014DA  6600 001C                553              BNE     opSUB01             * no, jmp to reg mode first
000014DE  4EB9 0000192E            554              JSR     getEA               * print off effective address
000014E4  14FC 002C                555              MOVE.B  #',',(A2)+          * add comma
000014E8  14FC 0044                556              MOVE.B  #'D',(A2)+          * add register BAM!
000014EC  4EB9 000017D0            557              JSR     highRegBits         * Add register number to buffer
000014F2  4EF9 0000150C            558              JMP     end1001             * jump to exit of sub: hex1_1101
000014F8                           559              
000014F8  14FC 0044                560  opSUB01     MOVE.B  #'D',(A2)+          * start register entry
000014FC  4EB9 000017D0            561              JSR     highRegBits         * add register number
00001502  14FC 002C                562              MOVE.B  #',',(A2)+          * add comma
00001506  4EB9 0000192E            563              JSR     getEA               * finish with EA          
0000150C                           564              
0000150C  4E75                     565  end1001     RTS            
0000150E                           566  
0000150E  4EB9 0000189A            567  hex1_1010   JSR     badInst             * Invalid Instruction
00001514  4E75                     568              RTS
00001516                           569  
00001516                           570  
00001516                           571  
00001516                           572  ********************************************************************************************************************** 
00001516                           573  * Case for: first four bits = 1011
00001516                           574  * --(CMP)
00001516                           575  ********************************************************************************************************************** 
00001516  4EB9 00001790            576  hex1_1011   JSR     getSize             * return size  in 6 & 7 into D6
0000151C  BC3C 0003                577              CMP.B   #%11,D6             * determine if a CMPA
00001520  6600 005A                578              BNE     opCMPEOR
00001524  14FC 0043                579              MOVE.B  #'C',(A2)+          * Put SUBA into Buff
00001528  14FC 004D                580              MOVE.B  #'M',(A2)+
0000152C  14FC 0050                581              MOVE.B  #'P',(A2)+
00001530  14FC 0041                582              MOVE.B  #'A',(A2)+
00001534  14FC 002E                583              MOVE.B  #'.',(A2)+
00001538  3C07                     584              MOVE.W  D7,D6               * fresh copy of instruction
0000153A  E08E                     585              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
0000153C  0246 0001                586              ANDI.W  #$0001,D6           * Isolate last bit for size
00001540  BC3C 0001                587              CMP.B   #%1,D6              * compare for a 1 to determine
00001544  6700 000C                588              BEQ     cmpaL               * jump to long, else word
00001548  14FC 0057                589              MOVE.B  #'W',(A2)+          * add word size into buffer
0000154C  4EF9 00001556            590              JMP     opCMPA              * Skip to adding padding and destination
00001552  14FC 004C                591  cmpaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
00001556  14FC 0020                592  opCMPA      MOVE.B  #' ',(A2)+
0000155A  14FC 0020                593              MOVE.B  #' ',(A2)+
0000155E  14FC 0020                594              MOVE.B  #' ',(A2)+
00001562                           595  
00001562  4EB9 0000192E            596              JSR     getEA               * get source operand
00001568  14FC 002C                597              MOVE.B  #',',(A2)+
0000156C  14FC 0041                598              MOVE.B  #'A',(A2)+
00001570  4EB9 000017D0            599              JSR     highRegBits         * Get address register number
00001576  4EF9 000015C8            600              JMP     end1011             * Skip to end of sub: hex1_1011
0000157C                           601              
0000157C  3C07                     602  opCMPEOR    MOVE.W  D7,D6               * fresh value
0000157E  4EB9 000017E2            603              JSR     getDirBit           * determine the direction bit 1 = eor 0 = cmp
00001584  BC3C 0000                604              CMP.B   #%0,D6              * yes, go into CMP     
00001588                           605                     
00001588  14FC 0043                606  opCMP       MOVE.B  #'C',(A2)+          * Populate CMP
0000158C  14FC 004D                607              MOVE.B  #'M',(A2)+
00001590  14FC 0050                608              MOVE.B  #'P',(A2)+
00001594  14FC 002E                609              MOVE.B  #'.',(A2)+
00001598  4EB9 0000179A            610              JSR     size2Buffer         * Determine & add size to buffer
0000159E  14FC 0020                611              MOVE.B  #' ',(A2)+
000015A2  14FC 0020                612              MOVE.B  #' ',(A2)+
000015A6  14FC 0020                613              MOVE.B  #' ',(A2)+
000015AA  14FC 0020                614              MOVE.B  #' ',(A2)+
000015AE  4EB9 0000192E            615              JSR     getEA               * Source Operand
000015B4  14FC 002C                616              MOVE.B  #',',(A2)+
000015B8  14FC 0044                617              MOVE.B  #'D',(A2)+  
000015BC  4EB9 000017D0            618              JSR     highRegBits         * Add register number to buffer
000015C2  4EF9 000015C8            619              JMP     end1011             * Skip to end of sub: hex1_1011
000015C8                           620        
000015C8                           621  
000015C8  4E75                     622  end1011     RTS
000015CA                           623  
000015CA                           624  
000015CA                           625  
000015CA                           626  
000015CA                           627  ********************************************************************************************************************** 
000015CA                           628  * Case for: first four bits = 1100
000015CA                           629  * MULU
000015CA                           630  ********************************************************************************************************************** 
000015CA  3C07                     631  hex1_1100   MOVE.W  D7,D6               * copy instruction for testing
000015CC  EC8E                     632  opMULU      LSR.L   #6,D6               * shift 6 to prep for mulu testing
000015CE  0246 0003                633              ANDI.W  #$3,D6              * mask last 3 bits
000015D2  BC3C 0003                634              CMP.B   #$3,D6              * is this MULU or MULS?
000015D6  6700 0002                635              BEQ     muluMode            * head to mulu  mode to determine immediate  
000015DA  3C07                     636  muluMode    MOVE.W  D7,D6               * fresh copy
000015DC  E68E                     637              LSR.L   #3,D6               * shift bits 3-5 into LSB
000015DE  0246 0007                638              ANDI.W  #$7,D6              * mask for mode bits
000015E2  BC3C 0007                639              CMP.B   #$7,D6              *
000015E6  6700 0008                640              BEQ     movePTR             * increment pointer by word
000015EA  4EF9 0000189A            641              JMP     badInst     
000015F0                           642  
000015F0  5448                     643  movePTR     ADDQ.W  #2,A0               * increment pointer
000015F2  4EF9 0000189A            644              JMP     badInst
000015F8                           645          
000015F8                           646  
000015F8  4E75                     647  end1100     RTS
000015FA                           648  
000015FA                           649  ********************************************************************************************************************** 
000015FA                           650  * Case for: first four bits = 1101
000015FA                           651  * --(ADD,ADDA)
000015FA                           652  ********************************************************************************************************************** 
000015FA  14FC 0041                653  hex1_1101   MOVE.B  #'A',(A2)+          * Put ADD into Buff
000015FE  14FC 0044                654              MOVE.B  #'D',(A2)+
00001602  14FC 0044                655              MOVE.B  #'D',(A2)+
00001606  4EB9 00001790            656              JSR     getSize             * return size  in 6 & 7 into D6
0000160C  BC3C 0003                657              CMP.B   #%11,D6             * determine if a ADD or ADDA
00001610  6600 004E                658              BNE     opADD               * not size 11, then skip to ADD
00001614  14FC 0041                659              MOVE.B  #'A',(A2)+          * yep, detected 11 then ADDA
00001618  14FC 002E                660              MOVE.B  #'.',(A2)+
0000161C  3C07                     661              MOVE.W  D7,D6               * fresh copy of instruction
0000161E  E08E                     662              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
00001620  0246 0001                663              ANDI.W  #$0001,D6           * Isolate last bit for size
00001624  BC3C 0001                664              CMP.B   #%1,D6              * compare for a 1 to determine
00001628  6700 000C                665              BEQ     addaL               * jump to long, else word
0000162C  14FC 0057                666              MOVE.B  #'W',(A2)+          * add word size into buffer
00001630  4EF9 0000163A            667              JMP     opADDA
00001636  14FC 004C                668  addaL       MOVE.B  #'L',(A2)+          * add long size into buffer           
0000163A  14FC 0020                669  opADDA      MOVE.B  #' ',(A2)+
0000163E  14FC 0020                670              MOVE.B  #' ',(A2)+
00001642  14FC 0020                671              MOVE.B  #' ',(A2)+
00001646                           672              **** NOTE NEED TO TEST FOR EA to ADD $
00001646  4EB9 0000192E            673              JSR     getEA               * get source operand
0000164C  14FC 002C                674              MOVE.B  #',',(A2)+
00001650  14FC 0041                675              MOVE.B  #'A',(A2)+  
00001654  4EB9 000017D0            676              JSR     highRegBits         * Add register number to buffer
0000165A  4EF9 000016B6            677              JMP     end1101
00001660                           678              
00001660  14FC 002E                679  opADD       MOVE.B  #'.',(A2)+          * finish putting Add.x to buffer
00001664  4EB9 0000179A            680              JSR     size2Buffer         * Determine Size and Add to Buffer
0000166A  14FC 0020                681              MOVE.B  #' ',(A2)+
0000166E  14FC 0020                682              MOVE.B  #' ',(A2)+
00001672  14FC 0020                683              MOVE.B  #' ',(A2)+
00001676  14FC 0020                684              MOVE.B  #' ',(A2)+
0000167A  4EB9 000017E2            685              JSR     getDirBit           * get Direction Bit 0 = EA 1 =regs
00001680  BC3C 0000                686              CMP.B   #%0,D6              * is this EA first?
00001684  6600 001C                687              BNE     opADD01             * no, jmp to reg mode first
00001688  4EB9 0000192E            688              JSR     getEA               * print off effective address
0000168E  14FC 002C                689              MOVE.B  #',',(A2)+          * add comma
00001692  14FC 0044                690              MOVE.B  #'D',(A2)+          * add register BAM!
00001696  4EB9 000017D0            691              JSR     highRegBits         * Add register number to buffer
0000169C  4EF9 000016B6            692              JMP     end1101             * jump to exit of sub: hex1_1101
000016A2                           693              
000016A2  14FC 0044                694  opADD01     MOVE.B  #'D',(A2)+          * start register entry
000016A6  4EB9 000017D0            695              JSR     highRegBits         * add register number
000016AC  14FC 002C                696              MOVE.B  #',',(A2)+          * add comma
000016B0  4EB9 0000192E            697              JSR     getEA               * finish with EA 
000016B6                           698  
000016B6  4E75                     699  end1101     RTS
000016B8                           700  
000016B8                           701  
000016B8                           702  
000016B8                           703  ********************************************************************************************************************** 
000016B8                           704  * Beginning of 4xxx Op Codes table: tbl_0100 
000016B8                           705  * Contains the functions per the second  4 bits of current instruction.
000016B8                           706  ********************************************************************************************************************** 
000016B8                           707  tbl_0100    *Jump table for all op codes that start with 4XXX
000016B8  4EF9 00001700            708              JMP     hex4_0000            
000016BE  4EF9 00001708            709              JMP     hex4_0001            
000016C4                           710              ;JMP     hex4_0010
000016C4                           711              ;JMP     hex4_0011
000016C4                           712              ;JMP     hex4_0100
000016C4  4EF9 00001718            713              JMP     hex4_0101
000016CA                           714              ;JMP     hex4_0110
000016CA  4EF9 00001720            715              JMP     hex4_0111
000016D0  4EF9 00001728            716              JMP     hex4_1000
000016D6  4EF9 00001742            717              JMP     hex4_1001
000016DC  4EF9 0000174A            718              JMP     hex4_1010
000016E2  4EF9 00001752            719              JMP     hex4_1011
000016E8  4EF9 0000175A            720              JMP     hex4_1100
000016EE  4EF9 00001762            721              JMP     hex4_1101
000016F4  4EF9 00001772            722              JMP     hex4_1110
000016FA  4EF9 0000176A            723              JMP     hex4_1111
00001700                           724              
00001700  4EB9 0000189A            725  hex4_0000   JSR     badInst
00001706  4E75                     726              RTS
00001708                           727              
00001708  4EB9 0000189A            728  hex4_0001   JSR     badInst
0000170E  4E75                     729              RTS
00001710                           730              
00001710  4EB9 0000189A            731  hex4_0011   JSR     badInst
00001716  4E75                     732              RTS
00001718                           733                            
00001718                           734              
00001718  4EB9 0000189A            735  hex4_0101   JSR     badInst
0000171E  4E75                     736              RTS
00001720                           737          
00001720                           738              
00001720  4EB9 0000189A            739  hex4_0111   JSR     badInst
00001726  4E75                     740              RTS
00001728                           741              
00001728                           742              
00001728                           743  ********************************************************************************************************************** 
00001728                           744  * Case for: 0100 1000 (MOVEM)                                                          
00001728                           745  ********************************************************************************************************************** 
00001728  3C07                     746  hex4_1000   MOVE.W  D7,D6           * copy instruction
0000172A  E88E                     747              LSR.L   #shift4bits,D6      * shift by 4 bits
0000172C  0246 000F                748              ANDI.W  #$000F,D6       * isolate last byte
00001730  BC3C 0004                749              CMP.B   #$4,D6          * Determine if SWAP
00001734  6600 0004                750              BNE     opMOVEM         * No - go to MOVEM
00001738                           751  
00001738  4E75                     752              RTS            
0000173A                           753  
0000173A  4EB9 0000189A            754  opMOVEM     JSR     badInst
00001740  4E75                     755              RTS   
00001742                           756  
00001742  4EB9 0000189A            757  hex4_1001   JSR     badInst
00001748  4E75                     758              RTS   
0000174A  4EB9 0000189A            759  hex4_1010   JSR     badInst
00001750  4E75                     760              RTS   
00001752  4EB9 0000189A            761  hex4_1011   JSR     badInst
00001758  4E75                     762              RTS
0000175A  4EB9 0000189A            763  hex4_1100   JSR     badInst
00001760  4E75                     764              RTS
00001762  4EB9 0000189A            765  hex4_1101   JSR     badInst
00001768  4E75                     766              RTS
0000176A  4EB9 0000189A            767  hex4_1111   JSR     badInst
00001770  4E75                     768              RTS   
00001772                           769  
00001772                           770  
00001772                           771  ********************************************************************************************************************** 
00001772                           772  * Case for: 0100 1110 (NOP)                                                      
00001772                           773  ********************************************************************************************************************** 
00001772  4EB9 00001790            774  hex4_1110   JSR     getSize             * determine the size for (JSR,JMP)
00001778  BC3C 0002                775              CMP.B   #%10,D6             * test size bits is this JSR? (0100 1110 10..)
0000177C  6600 011C                776              BNE     badInst             * No set badFlag for illegal instruction
00001780                           777               
00001780  14FC 004E                778              MOVE.B  #'N',(A2)+          * yes - print NOP to goodBuff
00001784  14FC 004F                779              MOVE.B  #'O',(A2)+
00001788  14FC 0050                780              MOVE.B  #'P',(A2)+
0000178C  4E75                     781              RTS
0000178E                           782  
0000178E                           783              
0000178E  4E75                     784  hex2_1111   RTS    
00001790                           785  
00001790                           786  
00001790                           787  ********************************************************************************************************************** 
00001790                           788  * Beginning of functions: badInst, getSize, size2Buffer, 
00001790                           789  ********************************************************************************************************************** 
00001790  3C07                     790  getSize     MOVE.W  D7,D6               * copy current instruction to shift
00001792  EC4E                     791              LSR.W   #6,D6               * move the size bits in 6-7 to LSB
00001794  0246 0003                792              ANDI.W  #$0003,D6           * remove other non-size bits and store result into D6
00001798  4E75                     793              RTS
0000179A                           794  
0000179A  4EB8 1790                795  size2Buffer JSR     getSize             * run sizing Commands
0000179E  BC3C 0000                796              CMP.B   #%00,D6             * is tihs a byte?
000017A2  6700 001C                797              BEQ     mainB               * yes, add B to buffer
000017A6  BC3C 0001                798              CMP.B   #%01,D6             * is this a word?
000017AA  6700 001E                799              BEQ     mainW               * yes, add teh W to buffer
000017AE  BC3C 0002                800              CMP.B   #%10,D6             * is this a long?
000017B2  6600 00E6                801              BNE     badInst             * No? then bad instruction
000017B6                           802        
000017B6  14FC 004C                803              MOVE.B  #'L',(A2)+          * add L to buffer
000017BA  4EF9 000017CE            804              JMP     mainEnd             * end size2Buffer sub  
000017C0                           805              
000017C0  14FC 0042                806  mainB       MOVE.B  #'B',(A2)+          * add B to buffer
000017C4  4EF9 000017CE            807              JMP     mainEnd             * end size2Buffer sub
000017CA                           808              
000017CA  14FC 0057                809  mainW       MOVE.B  #'W',(A2)+          * add W to buffer
000017CE  4E75                     810  mainEnd     RTS                         * end size2Buffer sub                        
000017D0                           811  
000017D0  3C07                     812  highRegBits MOVE.W  D7,D6               * get fresh copy of instruction
000017D2  E08E                     813              LSR.L   #shift8bits,D6          * shift by 8 (9total)
000017D4  E28E                     814              LSR.L   #1,D6               * shift by 1
000017D6  0206 0007                815              ANDI.B  #$7,D6              * isolate last 7 bits for register number
000017DA  0606 0030                816              ADD.B   #$30,D6             * convert register number to ascii
000017DE  14C6                     817              MOVE.B  D6,(A2)+            * put register numbert into buffer
000017E0  4E75                     818              RTS
000017E2                           819  
000017E2  3C07                     820  getDirBit   MOVE.W  D7,D6               * get fresh copy of instruction
000017E4  E08E                     821              LSR.L   #shift8bits,D6          * shift to right to isolate 8th bits
000017E6  0206 0001                822              ANDI.B  #01,D6              * isolate last bit for testing & return in D6
000017EA  4E75                     823              RTS  
000017EC                           824              
000017EC  BC3C 0000                825  getAddr     CMP.B   #%00,D6             * test if value is a byte - assumes D6 already loaded
000017F0  6700 0286                826              BEQ     byte2Buffer         * yes? - load B worth of address into buffer
000017F4  BC3C 0001                827              CMP.B   #%01,D6             * test if value is a word - assumes D6 already loaded
000017F8  6700 02AC                828              BEQ     word2Buffer         * yes? - load W worth of address into buffer
000017FC  BC3C 0002                829              CMP.B   #%10,D6             * test if value is a long - assumes D6 already loaded
00001800  6700 02D6                830              BEQ     long2Buffer         * yes? - load L worth of address into buffer
00001804  4E75                     831              RTS
00001806                           832  
00001806  4EB9 00001864            833  getLong     JSR     cmdSh1              * Clear D6 and load value for shift
0000180C  183C 000C                834              MOVE.B  #shift12bits,D4         * Load shifter w/12
00001810  4EB9 0000186C            835              JSR     cmdSh2              * Shift
00001816  183C 0008                836              MOVE.B  #shift8bits,D4          * Load shifter w/8
0000181A  4EB9 0000186C            837              JSR     cmdSh2              * Shift
00001820  183C 0004                838              MOVE.B  #shift4bits,D4          * Load shifter w/4
00001824  4EB9 0000186C            839              JSR     cmdSh2              * Shift
0000182A  183C 0000                840              MOVE.B  #0,D4
0000182E  4EB9 00001886            841              JSR     cmdSh4              * Shift
00001834  183C 000C                842              MOVE.B  #shift12bits,D4         * Load shifter w/12
00001838  4EB9 00001886            843              JSR     cmdSh4              * Shift
0000183E  183C 0008                844              MOVE.B  #shift8bits,D4          * Load shifter w/8
00001842  4EB9 00001886            845              JSR     cmdSh4              * Shift
00001848  183C 0004                846              MOVE.B  #shift4bits,D4          * Load shifter w/4
0000184C  4EB9 00001886            847              JSR     cmdSh4              * Shift
00001852  183C 0000                848              MOVE.B  #0,D4               * Load shifter
00001856  E8AE                     849              LSR.L   D4,D6               * Shift
00001858  0286 0000000F            850              ANDI.L  #$0000000F,D6       * Isolate last bit
0000185E  4EB9 00001916            851              JSR     Hex2ASCII           * Place value in D6 into buffer
00001864                           852  
00001864  7C00                     853  cmdSh1      MOVEQ   #$0,D6              * Clear D6
00001866  2C08                     854              MOVE.L  A0,D6               * Load current address to print
00001868  4846                     855              SWAP    D6                  * Swap high and low word
0000186A  4E75                     856              RTS
0000186C                           857  
0000186C  E8AE                     858  cmdSh2      LSR.L   D4,D6               * Shift
0000186E  0286 0000000F            859              ANDI.L  #$0000000F,D6       * Isolate last bit
00001874  4EB9 00001916            860              JSR     Hex2ASCII           * Place value in D6 into buffer
0000187A  4EB8 1864                861              JSR     cmdSh1              * Reset D6 for next shift
0000187E  4E75                     862              RTS
00001880                           863  
00001880  7C00                     864  cmdSh3      MOVEQ   #$0,D6              * Clear D6
00001882  2C08                     865              MOVE.L  A0,D6               * Load current address to print
00001884  4E75                     866              RTS
00001886                           867              
00001886  E8AE                     868  cmdSh4      LSR.L   D4,D6               * Shift
00001888  0286 0000000F            869              ANDI.L  #$0000000F,D6       * Isolate last bit
0000188E  4EB9 00001916            870              JSR     Hex2ASCII           * Place value in D6 into buffer
00001894  4EB8 1880                871              JSR     cmdSh3              * Reset D6 for next shift
00001898  4E75                     872              RTS
0000189A                           873              
0000189A  1A3C 0000                874  badInst    MOVE.B  #badFlag,D5         * set bad flag
0000189E  244B                     875              MOVEA.L A3,A2               * reset the buffer pointer 
000018A0  14FC 0044                876              MOVE.B  #'D',(A2)+          * add bad syntax to goodBuff
000018A4  14FC 0041                877              MOVE.B  #'A',(A2)+
000018A8  14FC 0054                878              MOVE.B  #'T',(A2)+
000018AC  14FC 0041                879              MOVE.B  #'A',(A2)+
000018B0  14FC 0009                880              MOVE.B  #$09,(A2)+
000018B4  14FC 0024                881              MOVE.B  #'$',(A2)+          * add in shift/pad
000018B8  4EB9 000018C0            882              JSR     getBadWord          * add the bad word to the buffer
000018BE  4E75                     883              RTS          
000018C0                           884  
000018C0  7C00                     885  getBadWord  MOVEQ   #$0,D6              * clear out D6 to use for copying word
000018C2  3C07                     886              MOVE.W  D7,D6               * copy word instruction to D6
000018C4  183C 000C                887              MOVE.B  #shift12bits,D4         * load shifter
000018C8  E8AE                     888              LSR.L   D4,D6               * Shift D6
000018CA  0246 000F                889              ANDI.W  #$000F,D6           * isolate last 4 bits
000018CE  4EB9 00001916            890              JSR     Hex2ASCII           * add 1st character to buffer
000018D4  3C07                     891              MOVE.W  D7,D6
000018D6  183C 0008                892              MOVE.B  #shift8bits,D4
000018DA  E8AE                     893              LSR.L   D4,D6
000018DC  0246 000F                894              ANDI.W  #$000F,D6
000018E0  4EB9 00001916            895              JSR     Hex2ASCII           * add 2nd character to buffer
000018E6  3C07                     896              MOVE.W  D7,D6
000018E8  183C 0004                897              MOVE.B  #shift4bits,D4
000018EC  E8AE                     898              LSR.L   D4,D6
000018EE  0246 000F                899              ANDI.W  #$000F,D6
000018F2  4EB9 00001916            900              JSR     Hex2ASCII           * add 3rd character to buffer
000018F8  3C07                     901              MOVE.W  D7,D6
000018FA  0246 000F                902              ANDI.W  #$000F,D6
000018FE  4EB9 00001916            903              JSR     Hex2ASCII           * add 4th character to buffer
00001904  4E75                     904              RTS
00001906                           905              
00001906  4280                     906  clrRegs     CLR.L   D0                  * clear all registers but D5 flag
00001908  4281                     907              CLR.L   D1
0000190A  4282                     908              CLR.L   D2
0000190C  4283                     909              CLR.L   D3
0000190E  4284                     910              CLR.L   D4
00001910  4286                     911              CLR.L   D6
00001912  4287                     912              CLR.L   D7
00001914  4E75                     913              RTS
00001916                           914  
00001916                           915  
00001916                           916  
00001916                           917  ********************************************************************************************************************** 
00001916                           918  * Hex to ASCII Routine
00001916                           919  ********************************************************************************************************************** 
00001916  BC3C 000A                920  Hex2ASCII   CMP.B   #$A,D6              * Confirm hex character?
0000191A  6C00 000A                921              BGE     letter              * Is it a letter or number?
0000191E  0606 0030                922              ADDI.B  #$30,D6             * Convert decimal to ASCII
00001922  6000 0006                923              BRA     write2Buff          * save to good buffer
00001926  0606 0037                924  letter      ADDI.B  #$37,D6
0000192A  14C6                     925  write2Buff  MOVE.B  D6,(A2)+
0000192C  4E75                     926              RTS
0000192E                           927              
0000192E                           928              
0000192E                           929  ********************************************************************************************************************** 
0000192E                           930  * EA Routine
0000192E                           931  ********************************************************************************************************************** 
0000192E                           932  getEA       
0000192E  4BF9 00001958            933              LEA         ea_mode_table,A5 * load EA_mode jump table
00001934  4282                     934              CLR.L   D2
00001936  4283                     935              CLR.L   D3
00001938  4284                     936              CLR.L   D4           
0000193A  4286                     937              CLR.L   D6
0000193C  3C07                     938              MOVE.W  D7,D6                 * move word into D6 for manipulation
0000193E  0246 003F                939              ANDI.W  #$003F,D6             * leave only the mode bits
00001942  123C 0003                940              MOVE.B      #3,D1                 * Store number of bits we wish to shift            
00001946  E26E                     941              LSR.W       D1,D6                 * Shift to the Right to isolate mode bits            
00001948                           942  
00001948  CCFC 0006                943              MULU      #6,D6            * Form Offset for passing to Jump Index table            
0000194C  4EB5 6000                944              JSR         00(A5,D6)          * Now we have the index, back to Index table        
00001950                           945  
00001950  4E75                     946              RTS                                * return from EA routine
00001952                           947          
00001952  4EF9 0000416A            948              JMP         END                    * Return
00001958                           949  
00001958                           950  *************************************** EA_mode jump table ************************************************************   
00001958                           951  ea_mode_table                             * table holds the different EA modes
00001958  4EF9 00001988            952              JMP     EAcode000             * Direct Data Register
0000195E  4EF9 0000199A            953              JMP     EAcode001             * Direct Address Register
00001964  4EF9 000019AC            954              JMP     EAcode010             * Indirect Address Register
0000196A  4EF9 000019C6            955              JMP     EAcode011             * Indirect Address Register with Post Increment
00001970  4EF9 000019E4            956              JMP     EAcode100             * Indirect Address Register with Pre Decrement
00001976  4EF9 00001A02            957              JMP     EAcode101             * Indirect Address Register using Index
0000197C  4EF9 00001A06            958              JMP     EAcode110             * 
00001982  4EF9 00001A0A            959              JMP     EAcode111             * Absolute or Immediate EA
00001988                           960  
00001988                           961  *********  Data Register Direct Dn ***********************************************************************************   
00001988                           962  EAcode000
00001988  3C07                     963              MOVE.W      D7,D6                   * move current working word into temp storage
0000198A  0246 0007                964              ANDI.W      #$7,D6                  * isolate register bits (last 3)
0000198E  14FC 0044                965              MOVE.B      #$44,(A2)+              * add "D" to buffer
00001992  0606 0030                966              ADD.B       #$30,D6                 * convert data register # to hex digit
00001996  14C6                     967              MOVE.B      D6,(A2)+                * register # to buffer                  
00001998                           968              
00001998  4E75                     969          RTS                                     * Return
0000199A                           970  
0000199A                           971  ********* Address Register Direct An **********************************************************************************   
0000199A                           972  EAcode001
0000199A  3C07                     973              MOVE.W      D7,D6                   * move current working word into temp storage
0000199C  0246 0007                974              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019A0  14FC 0041                975              MOVE.B      #$41,(A2)+              * add "A" to buffer
000019A4  0606 0030                976              ADD.B       #$30,D6                 * convert data register # to hex digit
000019A8  14C6                     977              MOVE.B      D6,(A2)+                * register # to buffer
000019AA                           978                
000019AA  4E75                     979          RTS                                 * Return
000019AC                           980  
000019AC                           981  ****** Address Register Indirect (An) *********************************************************************************  
000019AC                           982  EAcode010
000019AC  3C07                     983              MOVE.W      D7,D6                   * move current working word into temp storage
000019AE  0246 0007                984              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019B2  14FC 0028                985              MOVE.B      #$28,(A2)+              * add "(" to buffer            
000019B6  14FC 0041                986              MOVE.B      #$41,(A2)+              * add "A" to buffer
000019BA  0606 0030                987              ADD.B       #$30,D6                 * convert data register # to hex digit
000019BE  14C6                     988              MOVE.B      D6,(A2)+                * register # to buffer
000019C0  14FC 0029                989              MOVE.B      #$29,(A2)+              * add ")" to buffer
000019C4                           990               
000019C4  4E75                     991          RTS                                 * Return
000019C6                           992  
000019C6                           993  ********* Address Register Indirect w/ Post-Increment (An)+ ***********************************************************  
000019C6                           994  EAcode011
000019C6                           995              
000019C6  3C07                     996              MOVE.W      D7,D6                   * move current working word into temp storage
000019C8  0246 0007                997              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019CC  14FC 0028                998              MOVE.B      #$28,(A2)+              * add "(" to buffer            
000019D0  14FC 0041                999              MOVE.B      #$41,(A2)+              * add "A" to buffer
000019D4  0606 0030               1000              ADD.B       #$30,D6                 * convert data register # to hex digit
000019D8  14C6                    1001              MOVE.B      D6,(A2)+                * register # to buffer
000019DA  14FC 0029               1002              MOVE.B      #$29,(A2)+              * add ")" to buffer
000019DE  14FC 002B               1003              MOVE.B      #$2B,(A2)+              * add "+" to buffer
000019E2                          1004                   
000019E2  4E75                    1005          RTS                                 * Return
000019E4                          1006  
000019E4                          1007  *************** Address Register Indirect w/ Pre-Decrement -(An) ******************************************************  
000019E4                          1008  EAcode100
000019E4                          1009             
000019E4  3C07                    1010              MOVE.W      D7,D6                   * move current working word into temp storage
000019E6  0246 0007               1011              ANDI.W      #$7,D6                  * isolate register bits (last 3)
000019EA  14FC 002D               1012              MOVE.B      #$2D,(A2)+              * add "-" to buffer
000019EE  14FC 0028               1013              MOVE.B      #$28,(A2)+              * add "(" to buffer            
000019F2  14FC 0041               1014              MOVE.B      #$41,(A2)+              * add "A" to buffer
000019F6  0606 0030               1015              ADD.B       #$30,D6                 * convert data register # to hex digit
000019FA  14C6                    1016              MOVE.B      D6,(A2)+                * register # to buffer
000019FC  14FC 0029               1017              MOVE.B      #$29,(A2)+              * add ")" to buffer
00001A00                          1018              
00001A00  4E75                    1019          RTS                                     * Return
00001A02                          1020  
00001A02                          1021  
00001A02                          1022  
00001A02                          1023  ******************** Address Register Indirect w/ Displacement *********************************************************
00001A02                          1024  EAcode101
00001A02  4EF8 189A               1025               JMP    badInst          * set bad instruction flag
00001A06                          1026  
00001A06                          1027  
00001A06                          1028  ********************* Address Register w/ Index ************************************************************************
00001A06                          1029  EAcode110
00001A06  4EF8 189A               1030              JMP       badInst             * set bad instruction flag
00001A0A                          1031  
00001A0A                          1032  
00001A0A                          1033  
00001A0A                          1034  ******* Absolute (.W | .L) | Immediate | PC w/ Index | PC w/ Displacement **********************************************
00001A0A                          1035  EAcode111
00001A0A  4EB9 00001A36           1036              JSR      regBits             * Get Register bits
00001A10  0C06 0000               1037              CMPI.B   #$0,D6              * compare to determine if it's a word
00001A14  6700 0090               1038              BEQ      word2Buffer         * put word address in buffer
00001A18  0C06 0001               1039              CMPI.B   #$1,D6              * compare to determine if it's a long
00001A1C  6700 00BA               1040              BEQ      long2Buffer         * put long address in buffer
00001A20  0C06 0002               1041              CMPI.B   #$2,D6
00001A24                          1042  
00001A24  0C06 0002               1043              CMPI.B   #$2,D6              * compare to determine if it's PC w/ Displacement
00001A28  6700 0036               1044              BEQ      PCwDisp             
00001A2C  0C06 0004               1045              CMPI.B   #$4,D6              * compare to determine if it's Immediate
00001A30  6700 000C               1046              BEQ      imm2Buffer          * DON"T HAVE THIS CASE YET
00001A34                          1047             
00001A34  4E75                    1048              RTS
00001A36                          1049  
00001A36                          1050  *************************************************************************************************************************
00001A36                          1051  * EA SubRoutines   
00001A36                          1052  *************************************************************************************************************************  
00001A36                          1053  
00001A36                          1054  *** regBits ***
00001A36  3C07                    1055  regBits     MOVE.W  D7,D6     * change D2 to A0  (simulating address)
00001A38  0246 0007               1056              ANDI.W  #$07,D6
00001A3C  4E75                    1057              RTS
00001A3E                          1058              
00001A3E                          1059  **** imm2Buffer ***
00001A3E                          1060  imm2Buffer
00001A3E  14FC 0023               1061              MOVE.B      #'#',(A2)+
00001A42  4EB8 13A0               1062              JSR         moveSize
00001A46  0C06 0001               1063              CMPI.B      #$1,D6              * compare to determine if it's a word
00001A4A  6700 002C               1064              BEQ         byte2Buffer         * put word address in buffer
00001A4E  0C06 0003               1065              CMPI.B      #$3,D6              * compare to determine if it's a long
00001A52  6700 0052               1066              BEQ         word2Buffer         * put long address in buffer.            
00001A56  0C06 0002               1067              CMPI.B      #$2,D6
00001A5A  6700 007C               1068              BEQ         long2Buffer
00001A5E  4E75                    1069              RTS
00001A60                          1070              
00001A60                          1071  **** PCwDisp ***********************************************************************************************************
00001A60                          1072  PCwDisp
00001A60  4EB9 00001AA6           1073              JSR         word2Buffer
00001A66  14FC 0028               1074              MOVE.B      #$28,(A2)+              * add "(" to buffer            
00001A6A  14FC 0050               1075              MOVE.B      #$50,(A2)+              * add "P" to buffer
00001A6E  14FC 0043               1076              MOVE.B      #$43,(A2)+              * add "C" to buffer
00001A72  14FC 0029               1077              MOVE.B      #$29,(A2)+              * add ")" to buffer                        
00001A76  4E75                    1078              RTS
00001A78                          1079              
00001A78                          1080  **** byte2Buffer *******************************************************************************************************
00001A78                          1081  byte2Buffer   
00001A78  14FC 0024               1082              MOVE.B  #'$',(A2)+
00001A7C  4284                    1083              CLR.L   D4          * pre-emptive clearout
00001A7E  3410                    1084              MOVE.W  (A0),D2       * move current word into D2 for rolling purposes
00001A80  4284                    1085              CLR.L   D4          * pre-emptive clearout
00001A82  183C 0002               1086              MOVE.B  #2,D4       * load a counter
00001A86                          1087  
00001A86                          1088  b2bLoop                 
00001A86  B83C 0000               1089              CMP.B   #$00,D4     * compare counter with 0
00001A8A  6700 0014               1090              BEQ     rtnEA0      * if zero, return
00001A8E  E91A                    1091              ROL.B   #4,D2       * roll the bits in D2 to the left
00001A90  3C02                    1092              MOVE.W  D2,D6       * move rolled bits into temp storage
00001A92  0246 000F               1093              ANDI.W  #$000F,D6   * and the bits to isolate ascii char   
00001A96  4EB8 1916               1094              JSR     Hex2ASCII   * load ascii char into buffer            
00001A9A  5304                    1095              SUBQ.B  #$1,D4      * subtract from counter
00001A9C  4EF8 1A86               1096              JMP     b2bLoop     * keep looping until counter hits zero
00001AA0                          1097              
00001AA0  3C07                    1098  rtnEA0      MOVE.W  D7,D6       * re-load current word for temp storage            
00001AA2  5448                    1099              ADDQ.W  #2,A0       * advancing memory pointer by word   
00001AA4  4E75                    1100              RTS                 * return from subroutine
00001AA6                          1101              
00001AA6                          1102  **** word2Buffer *******************************************************************************************************
00001AA6                          1103  word2Buffer 
00001AA6  14FC 0024               1104              MOVE.B  #'$',(A2)+  
00001AAA  4284                    1105              CLR.L   D4          * pre-emptive clearout
00001AAC  14FC 0024               1106              MOVE.B  #$24,(A2)+  * put dollar sign in buffer (before address)
00001AB0  3410                    1107              MOVE.W  (A0),D2       * move current word into D2 for rolling purposes
00001AB2  4284                    1108              CLR.L   D4          * pre-emptive clearout
00001AB4  183C 0004               1109              MOVE.B  #4,D4       * load a counter
00001AB8                          1110  
00001AB8                          1111  w2bLoop                 
00001AB8  B83C 0000               1112              CMP.B   #$00,D4     * compare counter with 0
00001ABC  6700 0014               1113              BEQ     rtnEA1      * if zero, return
00001AC0  E95A                    1114              ROL.W   #4,D2       * roll the bits in D2 to the left
00001AC2  3C02                    1115              MOVE.W  D2,D6       * move rolled bits into temp storage
00001AC4  0246 000F               1116              ANDI.W  #$000F,D6   * and the bits to isolate ascii char   
00001AC8  4EB8 1916               1117              JSR     Hex2ASCII   * load ascii char into buffer            
00001ACC  5304                    1118              SUBQ.B  #$1,D4      * subtract from counter
00001ACE  4EF8 1AB8               1119              JMP     w2bLoop     * keep looping until counter hits zero
00001AD2                          1120              
00001AD2  3C07                    1121  rtnEA1      MOVE.W  D7,D6       * re-load current word for temp storage            
00001AD4  5448                    1122              ADDQ.W  #2,A0       * advancing memory pointer by word   
00001AD6  4E75                    1123              RTS                 * return from subroutine
00001AD8                          1124  
00001AD8                          1125  **** long2Buffer *******************************************************************************************************
00001AD8                          1126  long2Buffer
00001AD8  14FC 0024               1127              MOVE.B  #'$',(A2)+
00001ADC  4284                    1128              CLR.L   D4          * pre-emptive clearout
00001ADE  2410                    1129              MOVE.L  (A0),D2       * move current word into D2 for rolling purposes
00001AE0  4284                    1130              CLR.L   D4          * pre-emptive clearout
00001AE2  183C 0008               1131              MOVE.B  #8,D4       * load a counter
00001AE6                          1132  
00001AE6                          1133  l2bLoop                 
00001AE6  B83C 0000               1134              CMP.B   #$00,D4     * compare counter with 0
00001AEA  6700 0014               1135              BEQ     rtnEA2      * if zero, return
00001AEE  E99A                    1136              ROL.L   #4,D2       * roll the bits in D2 to the left
00001AF0  3C02                    1137              MOVE.W  D2,D6       * move rolled bits into temp storage
00001AF2  0246 000F               1138              ANDI.W  #$000F,D6   * and the bits to isolate ascii char   
00001AF6  4EB8 1916               1139              JSR     Hex2ASCII   * load ascii char into buffer            
00001AFA  5304                    1140              SUBQ.B  #$1,D4      * subtract from counter
00001AFC  4EF8 1AE6               1141              JMP     l2bLoop     * keep looping until counter hits zero
00001B00                          1142              
00001B00  3C07                    1143  rtnEA2      MOVE.W  D7,D6       * re-load current word for temp storage
00001B02  5848                    1144              ADDQ.W  #4,A0       * advancing memory pointer by long
00001B04  4E75                    1145              RTS                 * return from subroutine
00001B06                          1146  
00001B06                          1147  *********************************************************************************************************************
00001B06                          1148  * Beginning of data space:
00001B06                          1149  *********************************************************************************************************************     
00004000                          1150               ORG   $4000
00004000= 48 65 6C 6C 6F 2C ...   1151  intro        DC.B    'Hello, please enter beginning and ending addresses',CR,LF
00004034                          1152  
00004034= 0034                    1153  intro_len   DC.W    intro_len-intro
00004036                          1154          
00004036= 45 6E 74 65 72 20 ...   1155  string1     DC.B    'Enter starting address: $',0
00004050= 001A                    1156  str_len1    DC.W    str_len1-string1  *Get the length of the string
00004052                          1157  
00004052= 45 6E 74 65 72 20 ...   1158  string2     DC.B    'Enter ending address: $',0
0000406A= 0018                    1159  str_len2    DC.W    str_len2-string2  *Get the length of the string
0000406C                          1160  
0000406C= 45 72 72 6F 72 3A ...   1161  string3     DC.B    'Error: starting or ending address has equality error',0
000040A2= 0036                    1162  str_len3    DC.W    str_len3-string3
000040A4                          1163  
000040A4= 45 72 72 6F 72 3A ...   1164  err_start   DC.B    'Error: invalid hex values for starting address.',0
000040D4= FFD0                    1165  err_len1    DC.W    err_start-err_len1
000040D6                          1166  
000040D6= 45 72 72 6F 72 3A ...   1167  err_end     DC.B    'Error: invalid hex values for ending address.',0
00004104= FFD2                    1168  err_len2    DC.W    err_end-err_len2
00004106                          1169  
00004106= 50 72 65 73 73 20 ...   1170  str_enter   DC.B    'Press enter to read more data',0
00004124= FFE2                    1171  str_en_len  DC.W    str_enter-str_en_len
00004126                          1172  
00004126= 44 69 73 61 73 73 ...   1173  str_more    DC.B    'Disassemble more code? 1 for yes, 0 for no. ',0
00004154= 002E                    1174  strMore_len DC.W    strMore_len-str_more       
00004156                          1175  
00004156= 43 6C 6F 73 69 6E ...   1176  exit        DC.B    'Closing program',0
00004166= 0010                    1177  exit_len    DC.W    exit_len-exit           
00004168                          1178  
00004168= 01                      1179  message_buffer    DC.B   1
00004169                          1180                                   
00004169                          1181  *************************************************************************************************************************
00004169                          1182  * End of program:
00004169                          1183  *************************************************************************************************************************        
0000416A  4E72 2700               1184  END         STOP    #$2700
0000416E                          1185              END     $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDAL               1636
ASCIIERROR          1172
ASCIITOHEX          10F0
B2BLOOP             1A86
BADFLAG             0
BADINST             189A
BUFFPREP            1194
BYTE2BUFFER         1A78
CAP_TO_HEX          115E
CA_END              108C
CLEARALL            107A
CLRREGS             1906
CMDSH1              1864
CMDSH2              186C
CMDSH3              1880
CMDSH4              1886
CMPAL               1552
CR                  D
EACODE000           1988
EACODE001           199A
EACODE010           19AC
EACODE011           19C6
EACODE100           19E4
EACODE101           1A02
EACODE110           1A06
EACODE111           1A0A
EA_MODE_TABLE       1958
END                 416A
END0000             12B0
END0010             1316
END0011             137C
END0100             1434
END1001             150C
END1011             15C8
END1100             15F8
END1101             16B6
ENDBUFF             11D8
ENDINPUT            10EE
ERR_END             40D6
ERR_LEN1            40D4
ERR_LEN2            4104
ERR_START           40A4
EXIT                4156
EXIT_LEN            4166
FILL_ADDRESS        1186
GETADDR             17EC
GETBADWORD          18C0
GETDIRBIT           17E2
GETEA               192E
GETLONG             1806
GETOP               11F8
GETSIZE             1790
GOODFLAG            1
HEX1_0000           1258
HEX1_0001           12B2
HEX1_0011           1318
HEX1_0100           13D2
HEX1_0101           1436
HEX1_0110           143E
HEX1_0111           1448
HEX1_1001           1450
HEX1_1010           150E
HEX1_1011           1516
HEX1_1100           15CA
HEX1_1101           15FA
HEX2ASCII           1916
HEX2_1111           178E
HEX4_0000           1700
HEX4_0001           1708
HEX4_0011           1710
HEX4_0101           1718
HEX4_0111           1720
HEX4_1000           1728
HEX4_1001           1742
HEX4_1010           174A
HEX4_1011           1752
HEX4_1100           175A
HEX4_1101           1762
HEX4_1110           1772
HEX4_1111           176A
HIGHREGBITS         17D0
IMM2BUFFER          1A3E
INPUT               108E
INTRO               4000
INTRO_LEN           4034
IN_START            1016
L2BLOOP             1AE6
LETTER              1926
LF                  A
LONG2BUFFER         1AD8
LOOP2               1102
LOWER_TO_HEX        1168
MAINB               17C0
MAINEND             17CE
MAINW               17CA
MESSAGE_BUFFER      4168
MOVEL               12EC
MOVELEA             1300
MOVEPTR             15F0
MOVESIZE            13A0
MOVESIZEL           13CC
MOVESIZEW           13C2
MOVEW               1352
MOVEWEA             1366
MSIZEEND            13D0
MULUMODE            15DA
NUM_TO_HEX          1154
OPADD               1660
OPADD01             16A2
OPADDA              163A
OPCMP               1588
OPCMPA              1556
OPCMPEOR            157C
OPDECODE            11DA
OPLEA               1400
OPMOVEM             173A
OPMULU              15CC
OPORI               1270
OPRETURN            11F2
OPSUB               14B6
OPSUB01             14F8
OPSUBA              1490
PCWDISP             1A60
PRINTCOUNT          14
PRINT_EXIT          1066
PRINT_INTRO         1052
REGBITS             1A36
RESUME              113C
RETURN              117C
RTNEA0              1AA0
RTNEA1              1AD2
RTNEA2              1B00
SHIFT12BITS         C
SHIFT4BITS          4
SHIFT8BITS          8
SIZE2BUFFER         179A
STACK               A000
START               1000
STRING1             4036
STRING2             4052
STRING3             406C
STRMORE_LEN         4154
STR_ENTER           4106
STR_EN_LEN          4124
STR_LEN1            4050
STR_LEN2            406A
STR_LEN3            40A2
STR_MORE            4126
SUBAL               148C
SWAP4MOVE           137E
TASK0               0
TASK1               1
TASK13              D
TASK2               2
TBL_0100            16B8
TBL_OP              1210
W2BLOOP             1AB8
WORD2BUFFER         1AA6
WRITE2BUFF          192A
